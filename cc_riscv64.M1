## Copyright (C) 2017 Jeremiah Orians
## Copyright (C) 2021 Andrius Å tikonas
## Copyright (C) 2021 Gabriel Wicki
## This file is part of stage0.
##
## stage0 is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## stage0 is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with stage0.  If not, see <http://www.gnu.org/licenses/>.

; Register use:
; s1: malloc pointer
; s2: input fd
; s3: output fd
; s4: C, global_token
; s5: string_index, global_constant_list
; s6: Token, global_symbol_list
; s7: globals_list
; s8: global_function_list
; s9: output_list
; s10: current_count
; s11: function

; Struct TYPE format: (size 56)
; NEXT => 0
; SIZE => 8
; OFFSET => 16
; INDIRECT => 24
; MEMBERS => 32
; TYPE => 40
; NAME => 48

; Struct TOKEN_LIST format: (size 40)
; NEXT => 0
; LOCALS/PREV => 8
; S => 16
; TYPE => 24
; ARGS/DEPTH => 32

:_start
    rd_s7 mv                          ; Initialize globals_list
    rd_s8 mv                          ; Initialize global_function_list
    rd_s9 mv                          ; Initialize update_list

    rd_a2 rs1_sp !16 ld               ; Input file name

    ; Open input file and store FD in s2
    rd_a7 !56 addi                    ; sys_openat
    rd_a0 !-100 addi                  ; AT_FDCWD
    rd_a1 rs1_a2 mv                   ; file name
    rd_a2 addi                        ; read only
    ecall                             ; syscall
    rs1_a0 @Fail bltz                 ; Error opening file
    rd_s2 rs1_a0 mv                   ; Save fd in for later

    ; Set default FD for output file to stdout
    rd_s3 !1 addi

    ; If we only have 2 arguments, don't use the third (it's not set)
    rd_t0 !2 addi
    rd_a0 rs1_sp ld                   ; Get number of the args
    rs1_a0 rs2_t0 @Fail blt           ; No input file provided
    rs1_a0 rs2_t0 @after_open beq     ; No output file provided. Use stdout

    ; Open output file and store the FD in s3
    rd_a7 !56 addi                    ; sys_openat
    rd_a0 !-100 addi                  ; AT_FDCWD
    rd_a1 rs1_sp !24 ld               ; Output file (argument 3)
    rd_a2 !577 addi                   ; octal 00001101
    ; O_TRUNC   00001000
    ; O_CREAT   00000100
    ; O_WRONLY  00000001
    ; OCTAL!
    rd_a3 !384 addi                   ; Set read and write permission on user
    ecall                             ; syscall
    rd_s3 rs1_a0 mv                   ; Save fd in for later

:after_open
    ; Prepare heap memory
    rd_a7 !214 addi                   ; sys_brk
    rd_a0 addi                        ; Get current brk
    ecall                             ; syscall
    rd_s1 rs1_a0 mv                   ; Set our malloc pointer
    rd_a0 mv                          ; HEAD = NULL

    rd_ra $read_all_tokens jal        ; Read all tokens
    rd_ra $Reverse_List jal           ; Reverse order
    ;$debug_list jal                  ; Try to figure out what is wrong
    rd_s4 rs1_a0 mv                   ; Set global_token
    rd_s5 mv                          ; Initialize global_constant_list
    rd_s6 mv                          ; Initialize global_symbol_list
    rd_ra $program jal                ; Convert into program
    rd_a0 ~header_string1 auipc       ; Our header string
    rd_a0 rs1_a0 !header_string1 addi ; Our header string
    rd_ra $File_Print jal             ; Print it
    rd_a0 rs1_s9 mv                   ; Set output list
    rd_ra $recursive_output jal       ; Print them
    rd_a0 ~header_string2 auipc       ; Our header string
    rd_a0 rs1_a0 !header_string2 addi ; Our header string
    rd_ra $File_Print jal             ; Print it
    rd_a0 ~header_string3 auipc       ; Our second label
    rd_a0 rs1_a0 !header_string3 addi ; Our second label
    rd_ra $File_Print jal             ; Print it
    rd_a0 rs1_s7 mv                   ; Get globals
    rd_ra $recursive_output jal       ; Print them
    rd_a0 ~header_string4 auipc       ; Our third label
    rd_a0 rs1_a0 !header_string4 addi ; Our third label
    rd_ra $File_Print jal             ; Print it
    rd_a0 ~strings_list auipc         ; Our strings
    rd_a0 rs1_a0 !strings_list addi
    rd_a0 rs1_a0 ld
    rd_ra $recursive_output jal       ; Print them
    rd_a0 ~header_string5 auipc       ; Our final header
    rd_a0 rs1_a0 !header_string5 addi ; Our final header
    rd_ra $File_Print jal             ; Print it

:Done
    ; Terminate program with 0 return code
    rd_a7 !93 addi                    ; sys_exit
    rd_a0 mv                          ; Return code 0
    ecall                             ; exit(0)

:Fail
    ; Terminate program with 1 return code
    rd_a7 !93 addi                    ; sys_exit
    rd_a0 !1 addi                     ; Return code 1
    ecall                             ; exit(1)


;; read_all_tokens function
;; Receives FILE* in s2 and Token_List* in a0
;; Tokenizes all input and returns updated list in a0
;; Returns TOKEN in a0
;; Uses a0 for C
:read_all_tokens
    rd_sp rs1_sp !-8 addi                   ; allocate stack
    rs1_sp rs2_ra sd                        ; protect ra

    rd_s6 rs1_a0 mv                         ; Store Token
    rd_ra $fgetc jal
:read_all_tokens_loop
    rd_t0 !-4 addi                          ; Check for EOF
    rs1_a0 rs2_t0 @read_all_tokens_done beq ; Stop if found
    rd_ra $get_token jal                    ; Read all tokens
    $read_all_tokens_loop jal               ; Loop
:read_all_tokens_done
    rd_a0 rs1_s6 mv                         ; Return Token

    rd_ra rs1_sp ld                         ; restore ra
    rd_sp rs1_sp !8 addi                    ; deallocate stack
    ret


; get_token function
; Receives INT in a0 and FILE* in s2
; Makes a list of TOKEN_LIST
; s4 is used for C, s5 for STRING_INDEX,
; a2 is used for S and a3 is used for current
; Returns C in a0
:get_token
    rd_sp rs1_sp !-32 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3

    rd_s4 rs1_a0 mv                   ; Set C

    rd_a0 !40 mv                      ; Malloc CURRENT
    rd_ra $malloc jal                 ; Get Pointer
    rd_a3 rs1_a0 mv                   ; Set CURRENT

    rd_a0 !256 mv                     ; Malloc the string
    rd_ra $malloc jal                 ; Get Pointer to S
    rd_a2 rs1_a0 mv                   ; Set S
    rs1_a3 rs2_a2 @16 sd              ; CURRENT->S = S
:reset
    rd_s5 rs1_a2 mv                   ; S[0]
    rd_a0 rs1_s4 mv                   ; Using C

    rd_ra $clear_white_space jal      ; Clear WhiteSpace
    rd_s4 rs1_a0 mv                   ; Set C

    rd_t0 !-4 addi                    ; Check for EOF
    rs1_a0 rs2_t0 @get_token_abort beq ; abort if EOF

    rd_t0 !35 addi                    ; Check for '#'
    rs1_a0 rs2_t0 @get_token_alpha bne

    ; Deal with # line comments
    ; purge_macro function (inlined)
    ; Reads chars until LF is read and returns LF
:purge_macro
    rd_ra $fgetc jal                  ; read next char
    rd_t0 !10 addi                    ; Check for '\n'
    rs1_a0 rs2_t0 @purge_macro bne    ; Keep going

    rd_s4 rs1_a0 mv                   ; Set C
    $reset jal                        ; Try again

:get_token_alpha
    rd_a0 rs1_s4 mv                   ; Send C
    rd_a1 ~alphas auipc               ; Get alphanumerics
    rd_a1 rs1_a1 !alphas addi         ; Get alphanumerics
    rd_ra $In_Set jal                 ; See if in set
    rs1_a0 @get_token_symbol beqz     ; Otherwise process symbols

    ; Store keywords
    rd_a0 rs1_s4 mv                   ; Send C
    rd_ra $preserve_keyword jal       ; Store
    rd_s4 rs1_a0 mv                   ; Set C
    $get_token_done jal               ; Done with this token

:get_token_symbol
    rd_a0 rs1_s4 mv                   ; Send C
    rd_a1 ~symbols auipc              ; Get symbols
    rd_a1 rs1_a1 !symbols addi        ; Get symbols
    rd_ra $In_Set jal                 ; See if in set
    rs1_a0 @get_token_strings beqz    ; Otherwise process strings

    ; Store symbols
    rd_a0 rs1_s4 mv                   ; Send C
    rd_ra $preserve_symbol jal        ; Store
    rd_s4 rs1_a0 mv                   ; Set C
    $get_token_done jal               ; Done with this token

:get_token_strings
    rd_a0 rs1_s4 mv                   ; Send C
    rd_a1 ~strings auipc              ; Get strings
    rd_a1 rs1_a1 !strings addi        ; Get strings
    rd_ra $In_Set jal                 ; See if in set
    rs1_a0 @get_token_comment beqz    ; Otherwise process comments

    ; Store String
    rd_a0 rs1_s4 mv                   ; Send C
    rd_ra $consume_word jal           ; Store
    rd_s4 rs1_a0 mv                   ; Set C
    $get_token_done jal               ; Done with this token

:get_token_comment
    rd_a0 rs1_s4 mv                   ; Send C
    rd_t0 !47 addi                    ; '/'
    rs1_a0 rs2_t0 @get_token_else bne ; Check if C == '/'

    rd_ra $consume_byte jal           ; Hope it just is '/'
    rd_s4 rs1_a0 mv                   ; Set C

    rd_t0 !42 addi                    ; If '*' we have '/*'
    rs1_a0 rs2_t0 @get_token_comment_line bne ; Check for '//'

    ; Deal with /* block comments */
    rd_ra $fgetc jal                  ; get next C
    rd_s4 rs1_a0 mv                   ; Set C
:get_token_comment_block_outer
    rd_a0 rs1_s4 mv                   ; Using C
    rd_t0 !47 addi                    ; IF '/' != C
    rs1_a0 rs2_t0 @get_token_comment_block_done beq ; Done

:get_token_comment_block_inner
    rd_a0 rs1_s4 mv                   ; Using C
    rd_t0 !42 addi                    ; If '*' != C
    rs1_a0 rs2_t0 @get_token_comment_block_iter beq ; jump over

    ; Deal with inner loop
    rd_ra $fgetc jal                  ; Get next C
    rd_s4 rs1_a0 mv                   ; Set C
    $get_token_comment_block_inner jal ; keep going

:get_token_comment_block_iter
    rd_ra $fgetc jal                  ; Get next C
    rd_s4 rs1_a0 mv                   ; Set C
    $get_token_comment_block_outer jal

:get_token_comment_block_done
    rd_ra $fgetc jal                  ; Get next C
    rd_s4 rs1_a0 mv                   ; Set C
    $reset jal                        ; throw away, try again

:get_token_comment_line
    rd_t0 !47 addi                    ; IF '/' we have //
    rs1_a0 rs2_t0 @get_token_done bne ; keep if just '/'

    ; Deal with // line comment
    rd_ra $purge_macro jal            ; discard all until newline
    rd_s4 rs1_a0 mv                   ; Set C
    $reset jal                        ; throw away, try again

:get_token_else
    rd_a0 rs1_s4 mv                   ; Send C
    rd_ra $consume_byte jal
    rd_s4 rs1_a0 mv                   ; Set C

:get_token_done
    rs1_a3 rs2_s6 @8 sd               ; CURRENT->PREV = TOKEN
    rs1_a3 rs2_s6 sd                  ; CURRENT->NEXT = TOKEN
    rd_s6 rs1_a3 mv                   ; TOKEN = CURRENT

:get_token_abort
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_sp rs1_sp !32 addi             ; deallocate stack
    rd_a0 rs1_s4 mv                   ; Return C
    ret


; clear_white_space function
; Receives INT in a0 and FILE* in s2
; Returns first non-whitespace char in a0
:clear_white_space
    rd_sp rs1_sp !-8 addi                     ; allocate stack
    rs1_sp rs2_ra sd                          ; protect ra

:clear_white_space_loop
    rd_t0 !32 addi                            ; Check for ' '
    rs1_a0 rs2_t0 @clear_white_space_wipe beq ; wipe it out

    rd_t0 !10 addi                            ; Check for '\n'
    rs1_a0 rs2_t0 @clear_white_space_wipe beq ; wipe it out

    rd_t0 !9 addi                             ; Check for '\t'
    rs1_a0 rs2_t0 @clear_white_space_done bne ; looks like non-whitespace

:clear_white_space_wipe
    rd_ra $fgetc jal                          ; Read a new byte
    rd_t0 !-4 addi                            ; Check for EOF
    rs1_a0 rs2_t0 @clear_white_space_done beq ; We are done
    $clear_white_space_loop jal               ; iterate

:clear_white_space_done
    rd_ra rs1_sp ld                           ; restore ra
    rd_sp rs1_sp !8 addi                      ; deallocate stack
    ret


; preserve_keyword function
; Receives INT C in a0
; collects all chars in keyword
; Returns C in a0
; Uses a2 for INT C
:preserve_keyword
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a2 rs1_a0 mv                   ; Setup C
    rd_a1 ~alphas auipc               ; Get alphanumeric
    rd_a1 rs1_a1 !alphas addi         ; Get alphanumeric

:preserve_keyword_loop
    rd_ra $In_Set jal                 ; Check if alphanumeric
    rs1_a0 @preserve_keyword_label beqz ; Otherwise check for label

    rd_a0 rs1_a2 mv                   ; Pass C
    rd_ra $consume_byte jal           ; consume that byte
    rd_a2 rs1_a0 mv                   ; Update C
    $preserve_keyword_loop jal        ; Keep looping

:preserve_keyword_label
    rd_a0 rs1_a2 mv                   ; Fix return
    rd_t0 !58 addi                    ; Check for ':'
    rs1_a0 rs2_t0 @preserve_keyword_done bne ; Done

    ; Fix our goto label
    rd_ra $fixup_label jal            ; Fix the label
    rd_a0 !32 addi                    ; Return Whitespace

:preserve_keyword_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; preserve_symbol function
; Receives INT C in a0
; collects all chars in symbol
; Returns C in a0
; Uses a2 for INT C
:preserve_symbol
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a2 rs1_a0 mv                   ; Setup C
    rd_a1 ~symbols auipc              ; Get symbols
    rd_a1 rs1_a1 !symbols addi        ; Get symbols

:preserve_symbol_loop
    rd_ra $In_Set jal                 ; Check if symbol
    rs1_a0 @preserve_symbol_done beqz ; Continue if symbol

    rd_a0 rs1_a2 mv                   ; Pass C
    rd_ra $consume_byte jal           ; consume that byte
    rd_a2 rs1_a0 mv                   ; Update C
    $preserve_symbol_loop jal         ; keep looping

:preserve_symbol_done
    rd_a0 rs1_a2 mv                   ; Fix return
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; consume_word function
; receives INT C in a0
; returns INT C in a0
; Uses a0 for C, a1 for FREQ and a2 for ESCAPE
:consume_word
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a1 rs1_a0 mv                   ; FREQ = C
    rd_a2 mv                          ; ESCAPE = FALSE

:consume_word_loop
    rs1_a2 @consume_word_escape bnez  ; Enable escape if !ESCAPE

    rd_t0 !92 addi                    ; if '\\'
    rs1_a0 rs2_t0 @consume_word_iter bne ; keep state

    rd_a2 !1 addi                     ; ESCAPE = TRUE
    $consume_word_iter jal            ; keep going

:consume_word_escape
    rd_a2 mv                          ; ESCAPE = FALSE

:consume_word_iter
    rd_ra $consume_byte jal           ; read next char

    rs2_a2 @consume_word_loop bnez    ; keep looping if ESCAPE

    rs1_a0 rs2_a1 @consume_word_loop bnez ; keep going if C != FREQ

    rd_ra $fgetc jal                  ; return next char

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; consume_byte function
; Receives INT C in a0
; Inserts C into string S, updates String S
; Returns Next char in a0
:consume_byte
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1

    rd_a1 rs1_s5 mv                   ; S[0]
    rs1_a1 rs2_a0 sb                  ; S[0] = C
    rd_a1 rs1_a1 !1 addi              ; S = S + 1
    rd_s5 rs1_a1 mv                   ; Update S
    rd_ra $fgetc jal

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret


; fixup_label function
; Receives S in a2
; prepends ':' to string
; Uses a0 for HOLD, a1 for PREV and a2 for S[0]
:fixup_label
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_a0 sd                  ; protect a0
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a0 !58 addi                    ; HOLD = ':'
    rd_a2 rs1_a3 !16 ld               ; HOLD_STRING[0]
:fixup_label_loop
    rd_a1 rs1_a0 mv                   ; PREV = HOLD
    rd_a0 rs1_a2 lbu                  ; HOLD = HOLD_STRING[I]
    rs1_a2 rs2_a1 sb                  ; HOLD_STRING[I] = PREV
    rd_a2 rs1_a2 !1 addi              ; I = I + 1
    rs1_a0 @fixup_label_loop bnez     ; Keep looping if NULL == HOLD

    rd_a0 rs1_sp ld                   ; restore a0
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; fgetc function
; Loads FILE* from s2
; Returns -4 (EOF) or char in a0
:fgetc
    rd_sp rs1_sp !-32 addi            ; allocate stack
    rs1_sp rs2_ra @8 sd               ; protect ra
    rs1_sp rs2_a1 @16 sd              ; protect a1
    rs1_sp rs2_a2 @24 sd              ; protect a2

    rd_a7 !63 addi                    ; sys_read
    rd_a1 rs1_sp mv                   ; Get stack address for buffer
    rd_a0 rs1_s2 mv                   ; read from input file
    rd_a2 !1 addi                     ; read 1 character
    ecall                             ; syscall

    rs1_a0 @fgetc_done bnez           ; Check if nothing was read
    rd_a2 !-4 addi                    ; Use -4 as EOF
    rs1_a1 rs2_a2 sb                  ; Store EOF in *a1

:fgetc_done
    rd_a0 rs1_a1 lb                   ; return char in a0
    rd_ra rs1_sp !8 ld                ; restore ra
    rd_a1 rs1_sp !16 ld               ; restore a1
    rd_a2 rs1_sp !24 ld               ; restore a2
    rd_sp rs1_sp !32 addi             ; deallocate stack
    ret


; Reverse_List function
; Receives list in a0
; Returns the list reversed in a0
:Reverse_List
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_a1 sd                  ; protect a1
    rs1_sp rs2_a2 @8 sd               ; protect a2
    rd_a1 rs1_a0 mv                   ; Set HEAD
    rd_a0 mv                          ; ROOT = NULL
:Reverse_List_Loop
    rs1_a1 @Reverse_List_Done beqz    ; Stop if HEAD == NULL

    rd_a2 rs1_a1 ld                   ; NEXT = HEAD->NEXT
    rs1_a1 rs2_a0 sd                  ; HEAD->NEXT = ROOT
    rd_a0 rs1_a1 mv                   ; ROOT = HEAD
    rd_a1 rs1_a2 mv                   ; HEAD = NEXT
    $Reverse_List_Loop jal            ; Continue looping

:Reverse_List_Done
    rd_a1 rs1_sp ld                   ; restore a1
    rd_a2 rs1_sp !8 ld                ; restore a2
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret


; Malloc isn't actually required if the program being built fits in the initial memory
; However, it doesn't take much to add it.
; Requires MALLOC pointer to be initialized and a0 to have the number of desired bytes
:malloc
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1

    rd_a1 rs1_s1 mv                   ; Store the current pointer
    rd_a0 rs1_a0 rs2_s1 add           ; Request the number of desired bytes
    rd_a7 !214 addi                   ; sys_brk
    ecall                             ; syscall
    rd_s1 rs1_a0 mv                   ; Set our malloc pointer
    rd_a0 rs1_a1 mv                   ; Return the pointer

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret


; recursive_output function
; Receives list in a0
; walks the list and prints the I->S for all nodes backwards
; Uses a1 for I
:recursive_output
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rs1_a0 @recursive_output_done beqz ; Check if we are done
    rd_a1 rs1_a0 mv                   ; I = Head

    rd_a0 rs1_a1 ld                   ; I = I->next
    rd_ra $recursive_output jal       ; Recurse

    rd_a0 rs1_a1 !16 ld               ; Using S
    rd_ra $File_Print jal             ; Print it

:recursive_output_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; File_Print function
; Receives CHAR* in a0
; calls fputc for every non-null char
:File_Print
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rd_a1 rs1_a0 mv                   ; protect a0

    rs1_a0 @File_Print_Done beqz      ; Protect against nulls

:File_Print_Loop
    rd_a0 rs1_a1 lbu                  ; Read byte
    rs1_a0 @File_Print_Done beqz      ; Stop at NULL

    rd_ra $fputc jal                  ; print it
    rd_a1 rs1_a1 !1 addi              ; S = S + 1
    $File_Print_Loop jal              ; Keep printing

:File_Print_Done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; fputc function
; receives CHAR in a0 and load FILE* from s3
; writes char and returns
:fputc
    rd_sp rs1_sp !-32 addi            ; allocate stack
    rs1_sp rs2_a0 sd                  ; protect a0
    rs1_sp rs2_ra @8 sd               ; protect ra
    rs1_sp rs2_a1 @16 sd              ; protect a1
    rs1_sp rs2_a2 @24 sd              ; protect a2

    rd_a7 !64 addi                    ; sys_write
    rd_a0 rs1_s3 mv                   ; write to output
    rd_a1 rs1_sp mv                   ; Get stack address
    rd_a2 !1 addi                     ; write 1 character
    ecall                             ; syscall

    rd_a0 rs1_sp ld                   ; restore a0
    rd_ra rs1_sp !8 ld                ; restore ra
    rd_a1 rs1_sp !16 ld               ; restore a1
    rd_a2 rs1_sp !24 ld               ; restore a2
    rd_sp rs1_sp !32 addi             ; deallocate stack
    ret


; match function
; Receives CHAR* in a0 and CHAR* in a1
; Returns 0 (TRUE) or 1 (FALSE) in a0
:match
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_a1 sd                  ; protect a1
    rs1_sp rs2_a2 @8 sd               ; protect a2
    rs1_sp rs2_a3 @16 sd              ; protect a3

    rd_a2 rs1_a0 mv                   ; S1 in place
    rd_a3 rs1_a1 mv                   ; S2 in place

:match_Loop
    rd_a0 rs1_a2 lbu                  ; S1[i]
    rd_a1 rs1_a3 lbu                  ; S2[i]
    rs1_a0 rs2_a1 @match_False bne    ; Check if they match

    rd_a2 rs1_a2 !1 addi              ; S1 = S1 + 1
    rd_a3 rs1_a3 !1 addi              ; S2 = S2 + 1
    rs1_a0 @match_Done beqz           ; Match if we reached end of string
    $match_Loop jal                   ; Otherwise keep looping

:match_False
    rd_a0 !1 addi                     ; Return false
:match_Done
    rd_a1 rs1_sp ld                   ; restore a1
    rd_a2 rs1_sp !8 ld                ; restore a2
    rd_a3 rs1_sp !16 ld               ; restore a3
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; In_Set function
; Receives char C in a0 and Char* in a1
; Returns 1 if true, zero if false in a0
:In_Set
    rd_sp rs1_sp !-8 addi             ; allocate stack
    rs1_sp rs2_a1 sd                  ; protect a1

:In_Set_loop
    rd_t0 rs1_a1 lbu                  ; Read char
    rs1_a0 rs2_t0 @In_Set_True beq    ; Return true
    rs1_t0 @In_Set_False beqz         ; Return False if NULL
    rd_a1 rs1_a1 !1 addi              ; s = s + 1
    $In_Set_loop jal                  ; Continue looping

:In_Set_True
    rd_a0 !1 addi                     ; Set True
    rd_a1 rs1_sp ld                   ; restore a1
    rd_sp rs1_sp !8 addi              ; deallocate stack
    ret

:In_Set_False
    rd_a0 mv                          ; Set False
    rd_a1 rs1_sp ld                   ; restore a1
    rd_sp rs1_sp !8 addi              ; deallocate stack
    ret


; numerate_string function
; Receives CHAR* in a0
; Returns value of CHAR* in a0
; Uses a0 for VALUE, a1 for S, a2 for CH and a3 for NEGATIVE?
:numerate_string
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_a1 sd                  ; protect a1
    rs1_sp rs2_a2 @8 sd               ; protect a2
    rs1_sp rs2_a3 @16 sd              ; protect a3

    rd_a1 rs1_a0 mv                   ; put S in correct place
    rd_a0 mv                          ; Initialize to Zero
:numerate_string_loop
    rd_t0 rs1_a1 !1 addi              ; S + 1
    rd_a2 rs1_t0 lbu                  ; S[1]
    rd_t0 !120 addi                   ; 'x'
    rs1_a2 rs2_t0 @numerate_hex beq   ; Deal with hex_input

    ; Assume decimal input
    rd_a3 mv                          ; Assume no negation
    rd_a2 rs1_a1 lbu                  ; S[0]
    rd_t0 !45 addi                    ; '-'
    rs1_a2 rs2_t0 @numerate_decimal bne ; Skip negation

    rd_a3 !1 addi                     ; Set FLAG
    rd_a1 rs1_a1 !1 addi              ; S = S + 1

:numerate_decimal
    rd_a2 rs1_a1 lbu                  ; S[i]
    rs1_a2 @numerate_decimal_done beqz ; We are done if NULL == S[i]

    ; a0 = a0 * 10 = (a0 << 3) + (a0 << 1)
    rd_t0 rs1_a0 rs2_x3 slli          ; a0 * 8
    rd_t1 rs1_a0 rs2_x1 slli          ; a0 * 2
    rd_a0 rs1_t0 rs2_t1 add           ; VALUE = VALUE * 10
    rd_a2 rs1_a2 !-48 addi            ; CH = CH - '0'
    rd_t0 !9 addi                     ; t0 = 9
    rs1_t0 rs2_a2 @numerate_string_fail blt ; Check for illegal CH > 9
    rs1_a2 @numerate_string_fail bltz ; Check for illegal CH < 0
    rd_a0 rs1_a0 rs2_a2 add           ; VALUE = VALUE + CH
    rd_a1 rs1_a1 !1 addi              ; S = S + 1
    $numerate_decimal jal

:numerate_decimal_done
    rd_t0 !1 addi                     ; Check for negative FLAG
    rs1_a3 rs2_t0 @numerate_string_done bne ; Nope

    rd_a0 rs2_a0 sub                  ; VALUE = -VALUE
    $numerate_string_done jal         ; Done

:numerate_hex
    rd_a1 rs1_a1 !2 addi              ; S = S + 2
:numerate_hex_loop
    rd_a2 rs1_a1 lbu                  ; S[i]
    rs1_a2 @numerate_string_done beqz ; We are done if NULL == S[i]

    rd_a0 rs1_a0 rs2_x4 slli          ; VALUE = VALUE << 4
    rd_a2 rs1_a2 !-48 addi            ; CH = CH - '0'
    rd_t0 !10 addi                    ; t0 = 10
    rs1_a2 rs2_t0 @numerate_hex_digit blt ; Check if we are dealing with number or letter
    rd_a2 rs1_a2 !-7 addi             ; Push A-F into range

:numerate_hex_digit
    rd_t0 !15 addi                    ; t0 = 15
    rs1_t0 rs2_a2 @numerate_string_fail blt ; Check for CH > 'F'
    rs1_a2 @numerate_string_fail bltz ; Check for CH < 0
    rd_a0 rs1_a0 rs2_a2 add           ; VALUE = VALUE + CH
    rd_a1 rs1_a1 !1 addi              ; S = S + 1
    $numerate_hex_loop jal            ; Keep looping

:numerate_string_fail
    rd_a0 mv                          ; return ZERO

:numerate_string_done
    rd_a1 rs1_sp ld                   ; restore a1
    rd_a2 rs1_sp !8 ld                ; restore a2
    rd_a3 rs1_sp !16 ld               ; restore a3
    rd_sp rs1_sp !24 addi             ; deallocate stack
    rs1_ra jalr                       ; return


; numerate_number function
; Receives an INT A in a0
; Returns char* result in a0
; Allocates 16 bytes of memory
; Behaves badly when given a negative number too large
; Uses a0 for temp, a1 for DIVISOR, a3 for mod/0, a4 for result[i] and a2 for A
:numerate_number
    rd_sp rs1_sp !-48 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3
    rs1_sp rs2_a4 @32 sd              ; protect a4

    rd_a2 rs1_a0 mv                   ; Protect A
    rd_a0 !16 addi                    ; 16 bytes
    rd_ra $malloc jal                 ; Get our pointer
    rs1_sp rs2_a0 @40 sd              ; protect our pointer
    rd_a4 rs1_a0 mv                   ; Put pointer in right place
    rd_a1 ~0x3B9ACA00 lui             ; Set divisor to largest positive number that fits in 32bits
    rd_a1 rs1_a1 !0x3B9ACA00 addi     ; Set divisor to largest positive number that fits in 32bits

    rs1_a2 @numerate_number_ZERO beqz    ; Deal with 0 case
    rs2_a2 @numerate_number_positive blt ; Check if positive

    ; Deal with negative case
    rd_a0 !45 addi                    ; Using "-"
    rs1_a4 rs2_a0 sb                  ; Write it
    rd_a4 rs1_a4 !1 addi              ; increment
    rd_a2 rs2_a2 sub                  ; A = A * -1

:numerate_number_positive
    rd_t0 !10 addi                    ; 10
    rd_a0 rs1_a2 rs2_a1 divu          ; A / DIVISOR
    rs1_a0 @numerate_number_iter bnez ; Check if we have leading zeroes

    ; Clean up leading zeroes (DIVISOR = DIVISOR / 10)
    rd_a1 rs1_a1 rs2_t0 divu          ; Divide by 10
    $numerate_number_positive jal     ; Keep collecting

:numerate_number_iter
    rs1_a1 @numerate_number_done beqz ; Done if DIVISOR = 0

    rd_a0 rs1_a2 rs2_a1 divu          ; A / DIVISOR
    rd_a0 rs1_a0 !48 addi             ; A / DIVISOR + 48
    rs1_a4 rs2_a0 sb                  ; Write it
    rd_a2 rs1_a2 rs2_a1 remu          ; A % DIVISOR
    rd_a1 rs1_a1 rs2_t0 divu          ; Divide by 10
    rd_a4 rs1_a4 !1 addi              ; increment
    $numerate_number_iter jal         ; Keep going

:numerate_number_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_a4 rs1_sp !32 ld               ; restore a4
    rd_a0 rs1_sp !40 ld               ; restore our result
    rd_sp rs1_sp !48 addi             ; deallocate stack
    ret

:numerate_number_ZERO
    rd_a0 !48 addi                    ; Using '0'
    rs1_a4 rs2_a0 sb                  ; Write it
    rd_a4 rs1_a4 !1 addi              ; increment
    $numerate_number_done jal         ; Be done


; escape_lookup function
; Receives char* c in a0
; Returns integer value of char in a0
; Aborts hard if unknown escape is received
; Uses a2 to hold char* C
:escape_lookup
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a2 rs1_a0 mv                   ; Put char* C in safe place
    rd_a0 rs1_a2 lbu                  ; c[0]
    rd_t0 !92 addi                    ; '\'
    rs1_a0 rs2_t0 @escape_lookup_done bnez ; We are done If '\\' != c[0]

    rd_a1 rs1_a2 mv                   ; Prepare for walk
    rd_a1 rs1_a1 !1 addi              ; increment
    rd_a1 rs1_a1 lbu                  ; load c[1]

    rd_t0 !120 addi                   ; Check for \x
    rs1_a1 rs2_t0 @escape_lookup_hex beq ; Deal with hex

    ; Deal with \? escapes
    rd_a0 !10 addi                    ; Guess "\n"
    rd_t0 !110 addi                   ; n
    rs1_a1 rs2_t0 @escape_lookup_done beq ; If n than we are done

    rd_a0 !9 addi                     ; Guess "\t"
    rd_t0 !116 addi                   ; t
    rs1_a1 rs2_t0 @escape_lookup_done beq ; If t than we are done

    rd_a0 rs1_a1 mv                   ; "\\", "'" and '"' all encode as themselves
    rd_t0 !92 addi                    ; If "\"
    rs1_a1 rs2_t0 @escape_lookup_done beq ; Be done
    rd_t0 !39 addi                    ; If "'"
    rs1_a1 rs2_t0 @escape_lookup_done beq ; Be done
    rd_t0 !34 addi                    ; If """
    rs1_a1 rs2_t0 @escape_lookup_done beq ; Be done

    rd_a0 !13 addi                    ; Guess "\r"
    rd_t0 !114 addi                   ; r
    rs1_a1 rs2_t0 @escape_lookup_done beq ; If r than we are done

    ; Looks like we have no clue what we are doing
    ; Aborting hard
    rd_s3 !2 addi                     ; write to standard error
    rd_a0 ~escape_lookup_string_0 auipc ; Using "Unknown escape received: "
    rd_a0 rs1_a0 !escape_lookup_string_0 addi
    rd_ra $File_Print jal             ; Print it
    rd_a0 rs1_a2 mv                   ; Using C
    rd_ra $File_Print jal             ; Print it
    rd_a0 ~escape_lookup_string_1 auipc ; Using " Unable to process\n"
    rd_a0 rs1_a0 !escape_lookup_string_1 addi
    rd_ra $File_Print jal             ; Print it
    $Fail jal                         ; Abort Hard

:escape_lookup_hex
    ; Give up on C and just assume they know what they are doing
    rd_a2 rs1_a2 !2 addi              ; increment
    rd_a0 rs1_a2 lbu                  ; c[2]
    rd_a2 rs1_a2 !1 addi              ; increment
    rd_ra $char2hex jal               ; Get the hex value
    rd_a0 rs1_a0 rs2_x4 slli          ; c << 4
    rd_a1 rs1_a2 lbu                  ; c[3]
    rd_t3 rs1_a0 mv                   ; Protect c << 4
    rd_a0 rs1_a1 mv
    rd_a1 rs1_t3 mv
    rd_ra $char2hex jal               ; Get the hex value
    rd_a0 rs1_a0 rs2_a1 add           ; hex(c[2]) << 4 + hex(c[3])

:escape_lookup_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


;; char2hex function
;; Receives char in RAX
;; Returns hex or aborts hard
:char2hex
    rd_a0 rs1_a0 !-48 addi            ; Try 0-9
    rd_t0 !10 addi
    rs1_a0 rs2_t0 @char2hex_done blt  ; Done if digit

    ; Deal with A-F
    rd_t1 !0xDF addi                  ; Unset High bit turning a-f into A-F
    rd_a0 rs1_t1 rs2_a0 and           ; Do it
    rd_a0 rs1_a0 !-7 addi             ; Shift down into position
    rs1_a0 rs2_t0 @char2hex_fail blt  ; Everything below A is bad
    rd_t1 !16 addi
    rs1_a0 rs2_t0 @char2hex_done blt  ; Make sure we are below F

:char2hex_fail
    ; Time to fail hard
    rd_s3 !2 addi                     ; Write to standard error
    rd_a0 ~char2hex_string_0 auipc    ; Using "Tried to print non-hex number\n"
    rd_a0 rs1_a0 !char2hex_string_0 addi
    rd_ra $File_Print jal             ; Print it
    $Fail jal                         ; Abort Hard

:char2hex_done
    ret


; parse_string function
; Receives char* string in a0
; Returns cleaned up string
; Protects char* string in a1
:parse_string
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1

    rd_a1 rs1_a0 mv                   ; Protect char *string
    rd_ra $weird jal                  ; Determine if we have a weird string
    rs1_a0 @parse_string_weird beqz   ; Deal with it

    ; Dealing with regular string
    rd_a0 rs1_a1 mv                   ; Passing char* string
    rd_ra $collect_regular_string jal ; Collect it
    $parse_string_done jal            ; Be done

:parse_string_weird
    rd_a0 rs1_a1 mv                   ; Passing char* string
    rd_ra $collect_weird_string jal   ; Collect it

:parse_string_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret


; weird function
; Receives char* string in a0
; Returns true(0) or false(1) in a0
; Uses a2 to hold char* string
:weird
    rd_sp rs1_sp !-32 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3

    rd_a2 rs1_a0 mv                   ; Place string in safe place
    rd_a2 rs1_a2 !1 addi              ; increment past the "

:weird_reset
    rd_a0 rs1_a2 lbu                  ; Load a char
    rs1_a0 @weird_false beqz          ; Nothing weird found

    rd_t0 !92 addi                    ; IF '\\'
    rs1_a0 rs2_t0 @weird_escaped bne  ; Deal with escaping

    ; Deal with escape
    rd_a0 rs1_a2 mv                   ; We are passing the string
    rd_ra $escape_lookup jal          ; to look it up

    rd_a2 rs1_a2 !1 addi              ; string = string + 1
    rd_a1 rs1_a2 lbu                  ; get string[1]
    rd_t0 !120 addi                   ; IF 'x' == string[1]
    rs1_a1 rs2_t0 @weird_escaped bne  ; otherwise skip the gap

    rd_a2 rs1_a2 !2 addi              ; string = string + 2

:weird_escaped
    rd_a3 rs1_a0 mv                   ; Protect C in case we need it
    rd_a1 ~weird_string_0 auipc       ; Use "\t\n !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    rd_a1 rs1_a1 !weird_string_0 addi
    rd_ra $In_Set jal                 ; To find if weird
    rd_t0 rs1_a0 mv                   ; Move result to temporary
    rd_a0 rs1_a3 mv                   ; Restore C
    rs1_t0 @weird_true beqz           ; If in set then not weird

    rd_a2 rs1_a2 !1 addi              ; string = string + 1

    ; Last chance for weird
    rd_a1 ~weird_string_1 auipc       ; Use "\t\n\r "
    rd_a1 rs1_a1 !weird_string_1 addi
    rd_ra $In_Set jal                 ; Check for special case
    rs1_a0 @weird_reset beqz          ; Otherwise not in the special case

    ; Deal with possible special case
    rd_a0 rs1_a2 lbu                  ; Load string[1]
    rd_t0 !58 addi                    ; IF string[1] == ":"
    rs1_a0 rs2_t0 @weird_true beq     ; Then we git the special case
    $weird_reset jal                  ; Keep trying

:weird_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_sp rs1_sp !32 addi             ; deallocate stack
    ret

:weird_true
    rd_a0 mv                          ; Return true
    $weird_done jal                   ; Be done

:weird_false
    rd_a0 !1 addi                     ; Return false
    $weird_done jal                   ; Be done


; collect_regular_string function
; Receives char* string in a0
; Malloc and creates new string to return in a0 
; Uses a2 for return string and a3 for passed string
:collect_regular_string
    rd_sp rs1_sp !-40 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3

    rd_a3 rs1_a0 mv                   ; Protect our passed string
    rd_a0 !256 addi                   ; We need 256 bytes of storage
    rd_ra $malloc jal                 ; Get our new pointer
    rd_a2 rs1_a0 mv                   ; put it in place
    rs1_sp rs2_a0 @32 sd              ; protect until done

:collect_regular_string_reset
    rd_a0 rs1_a3 lbu                  ; string[0]
    rs1_a0 @collect_regular_string_done beqz ; See if we git the end

    rd_t0 !92 addi                    ; IF string[0] = '\\'
    rs1_a0 rs2_t0 @collect_regular_string_escaped beq ; Deal with escapes

    ; deal with boring char
    rs1_a2 rs2_a0 sb                  ; hold_string[index] = string[0]
    rd_a2 rs1_a2 !1 addi              ; Increment it
    rd_a3 rs1_a3 !1 addi              ; Increment it
    $collect_regular_string_reset jal ; And keep going

:collect_regular_string_escaped
    rd_a0 rs1_a3 mv                   ; Using string
    rd_ra $escape_lookup jal          ; Get the char
    rs1_a2 rs2_a0 sb                  ; hold_string[index] = escape_lookup(string)
    rd_a3 rs1_a3 !1 addi              ; Increment it
    rd_a2 rs1_a2 !1 addi              ; Increment it
    rd_a0 rs1_a3 lbu                  ; string[0]
    rd_a3 rs1_a3 !1 addi              ; Increment it
    rd_t0 !120 addi                   ; IF 'x' == string[1]
    rs1_a0 rs2_t0 @collect_regular_string_reset bne ; Otherwise keep going

    rd_a3 rs1_a3 !2 addi              ; Increment it
    $collect_regular_string_reset jal ; Keep going

:collect_regular_string_done
    rd_a0 !34 addi                    ; Using '"'
    rs1_a2 rs2_a0 sb                  ; hold_string[index] = '"'
    rd_a2 rs1_a2 !1 addi              ; Increment it
    rd_a0 !10 addi                    ; Using "\n"
    rs1_a2 rs2_a0 sb                  ; hold_string[index] = '\n'

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_a0 rs1_sp !32 ld               ; restore a0
    rd_sp rs1_sp !40 addi             ; deallocate stack
    ret


; collect_weird_string function
; Receives char* string in a0
; Mallocs and returns char* hold in a0
; Uses a2 for char* hold and a3 for char* string
:collect_weird_string
    rd_sp rs1_sp !-40 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3

    rd_a3 rs1_a0 mv                   ; Protect our passed string
    rd_a0 !512 addi                   ; We need 512 bytes of storage
    rd_ra $malloc jal                 ; Get our new pointer
    rd_a2 rs1_a0 mv                   ; put it in place
    rs1_sp rs2_a0 @32 sd              ; protect until done

    rd_a0 !39 addi                    ; Using "'"
    rs1_a2 rs2_a0 sb                  ; hold_string[index] = "'"
    rd_a2 rs1_a2 !1 addi              ; Increment it
    rd_a3 rs1_a3 !1 addi              ; Increment it

:collect_weird_string_reset
    rd_a0 rs1_a3 lbu                  ; Read a byte
    rs1_a0 @collect_weird_string_done beqz ; Be done IF NULL == string[0]

    rd_a0 !32 addi                    ; Using ' '
    rs1_a2 rs2_a0 sb                  ; hold_string[index] = ' '
    rd_a2 rs1_a2 !1 addi              ; Increment it

    rd_a0 rs1_a3 mv                   ; Using string
    rd_ra $escape_lookup jal          ; Get the char
    rd_ra $hex8 jal                   ; Update a3

    rd_a0 rs1_a3 lbu                  ; Read a byte
    rd_a3 rs1_a3 !1 addi              ; Increment it
    rd_t0 !92 addi                    ; IF string[0] == '\\'
    rs1_a0 rs2_t0 @collect_weird_string_reset bne ; Otherwise keep going

    rd_a0 rs1_a3 lbu                  ; Read a byte
    rd_a3 rs1_a3 !1 addi              ; Increment it
    rd_t0 !120 addi                   ; IF x == string[1]
    rs1_a0 rs2_t0 @collect_weird_string_reset bne ; Otherwise keep going

    rd_a3 rs1_a3 !2 addi              ; Increment it
    $collect_weird_string_reset jal   ; Keep going

:collect_weird_string_done
    rd_a0 !32 addi                    ; Using ' '
    rs1_a2 rs2_a0 sb                  ; hold_string[index] = ' '
    rd_a2 rs1_a2 !1 addi              ; Increment it
    rd_a0 !48 addi                    ; Using '0'
    rs1_a2 rs2_a0 sb                  ; hold_string[index] = '0'
    rd_a2 rs1_a2 !1 addi              ; Increment it
    rs1_a2 rs2_a0 sb                  ; hold_string[index] = '0'
    rd_a2 rs1_a2 !1 addi              ; Increment it
    rd_a0 !39 addi                    ; Using '''
    rs1_a2 rs2_a0 sb                  ; hold_string[index] = '''
    rd_a2 rs1_a2 !1 addi              ; Increment it
    rd_a0 !10 addi                    ; Using '\n'
    rs1_a2 rs2_a0 sb                  ; hold_string[index] = '\n'

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_a0 rs1_sp !32 ld               ; restore a0
    rd_sp rs1_sp !40 addi             ; deallocate stack
    ret


; HEX to ascii routine
; Receives INT in a0 and CHAR* in a2
; Stores ascii of INT in CHAR*
; Returns only modifying a0 and a2
:hex8
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; Protect ra
    rs1_sp rs2_a0 @8 sd               ; Protect bottom nibble
    rd_a0 rs1_a0 rs2_x4 srli          ; do high nibble first
    rd_ra $hex4 jal                   ; Store it
    rd_a0 rs1_sp !8 ld                ; do low nibble
    rd_ra $hex4 jal                   ; Store it
    rd_ra rs1_sp ld                   ; restore ra
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret

:hex4
    rd_t0 !0xF addi
    rd_a0 rs1_a0 rs2_t0 and           ; isolate nibble
    rd_a0 rs1_a0 !0x30 addi           ; convert to ascii
    rd_t0 !0x39 addi                  ; t0 = '9'
    rs1_t0 rs2_a0 @hex1 bge           ; check if valid digit
    rd_a0 rs1_a0 !7 addi              ; use alpha range
:hex1
    rs1_a2 rs2_a0 sb                  ; store result
    rd_a2 rs1_a2 !1 addi              ; next position
    ret

:enum_error_open_curly
"ERROR in enum
Expected {
"
:enum_error_equal
"ERROR in enum
Expected =
"
:enum_error_close_curly
"ERROR in enum
Expected }
"
:enum_error_semi_colon
"ERROR in enum
Expected ;
"

; program function
; receives nothing, returns nothing
; Uses a0 for type_size
:program
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    ; The binary initialized the globals to null, so we can skip those steps

:new_type
    rs1_s4 @program_done beqz         ; Be done if null

    rd_a1 rs1_s4 !16 ld               ; GLOBAL_TOKEN->S
    rd_a0 ~enum auipc                 ; "enum"
    rd_a0 rs1_a0 !enum addi
    rd_ra $match jal                  ; Check if GLOBAL_TOKEN->S == "enum"
    rs1_a0 @program_else bnez         ; Looks like not an enum

    ; Deal with minimal anonymous enums
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 ~enum_error_open_curly auipc ; Using "ERROR in enum\nExpected {\n"
    rd_a0 rs1_a0 !enum_error_open_curly addi
    rd_a1 ~open_curly_brace auipc     ; Using "{"
    rd_a1 rs1_a1 !open_curly_brace addi
    rd_ra $require_match jal          ; Require match and skip

:enumerator
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a1 mv                          ; NULL
    rd_a2 rs1_s5 mv                   ; global_constant_list
    rd_ra $sym_declare jal            ; Declare that constant
    rd_s5 rs1_a0 mv                   ; global_constant_list = sym_declare(global_token->s, NULL, global_constant_list);

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 ~enum_error_equal auipc     ; Using "ERROR in enum\nExpected =\n"
    rd_a0 rs1_a0 !enum_error_equal addi
    rd_a1 ~equal auipc                ; Using "="
    rd_a1 rs1_a1 !equal addi
    rd_ra $require_match jal          ; Require match and skip

    rs1_s5 rs2_s4 @32 sd              ; global_constant_list->arguments = global_token->next

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~comma auipc                ; ","
    rd_a0 rs1_a0 !comma addi
    rd_ra $match jal                  ; IF global_token->S == ","
    rs1_a0 @enum_end bnez             ; No comma means no more enumerators

    ; Skip comma
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    ; Check if there are more enumerators or if it was a trailing comma
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~close_curly_brace auipc    ; "}"
    rd_a0 rs1_a0 !close_curly_brace addi
    rd_ra $match jal                  ; IF global_token->S == "}"
    rs1_a0 @enumerator bnez           ; More enumerators

:enum_end
    rd_a0 ~enum_error_close_curly auipc ; Using "ERROR in enum\nExpected }\n"
    rd_a0 rs1_a0 !enum_error_close_curly addi
    rd_a1 ~close_curly_brace auipc    ; Using "}"
    rd_a1 rs1_a1 !close_curly_brace addi
    rd_ra $require_match jal          ; Require match and skip

    rd_a0 ~enum_error_semi_colon auipc ; Using "ERROR in enum\nExpected ;\n"
    rd_a0 rs1_a0 !enum_error_semi_colon addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Require match and skip

    $new_type jal                     ; go around again

:program_else
    rd_ra $type_name jal              ; Figure out the type_size
    rs1_a0 @new_type beqz             ; new type if NULL == type_size

    ; Add to global symbol table
    rd_a1 rs1_a0 mv                   ; put type_size in the right spot
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a2 rs1_s6 mv                   ; Using global_symbol_list
    rd_ra $sym_declare jal            ; Declare symbol
    rd_s6 rs1_a0 mv                   ; global_symbol_list = sym_declare(global_token->s, type_size, global_symbol_list);
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~semicolon auipc            ; ";"
    rd_a0 rs1_a0 !semicolon addi
    rd_ra $match jal                  ; match(";", global_token->s)
    rs1_a0 @program_function bnez     ; Check if we have a match

    ; Deal with the global variable
    rd_a1 rs1_s7 mv                   ; Using globals_list
    rd_a0 ~program_string_0 auipc     ; ":GLOBAL_"
    rd_a0 rs1_a0 !program_string_0 addi
    rd_ra $emit jal                   ; Emit it
    rd_a1 rs1_a0 mv                   ; Update globals_list

    rd_a0 rs1_s4 !8 ld                ; global_token->prev
    rd_a0 rs1_a0 !16 ld               ; global_token->prev->S
    rd_ra $emit jal                   ; Emit it

    rd_a1 rs1_a0 mv                   ; update globals_list
    rd_a0 ~program_string_1 auipc     ; "\nNULL\n"
    rd_a0 rs1_a0 !program_string_1 addi
    rd_ra $emit jal                   ; Emit it
    rd_s7 rs1_a0 mv                   ; update globals_list

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    $new_type jal                     ; go around again

:program_function
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~open_paren auipc           ; "("
    rd_a0 rs1_a0 !open_paren addi
    rd_ra $match jal                  ; (match(";", global_token->s)
    rs1_a0 @program_error bnez        ; Make sure we have a match

    ; Deal with function definition
    rd_ra $declare_function jal       ; Lets get the parsing rolling
    $new_type jal                     ; Keep looping through functions

:program_error
    ; Deal with the case of something we don't support

:program_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; sym_declare function
; Receives char *s in a0, struct type* t in a1, and struct token_list* list in a2
; Returns struct token_list* in a0
; Uses a0 for A
:sym_declare
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a3 @8 sd               ; protect a3
    rd_a3 rs1_a0 mv                   ; Get char *S safely out of the way

    rd_a0 !40 addi                    ; Using sizeof(struct token_list)
    rd_ra $malloc jal                 ; Get pointer to A
    rs1_a0 rs2_a2 sd                  ; A->NEXT = LIST
    rs1_a0 rs2_a3 @16 sd              ; A->S = S
    rs1_a0 rs2_a1 @24 sd              ; A->TYPE = T

    rd_ra rs1_sp ld                   ; restore ra
    rd_a3 rs1_sp !8 ld                ; restore a3
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret


; emit_out function
; Receives char* S in a0
; Returns nothing
; Updates output_list
; MUST NOT ALTER REGISTERS
:emit_out
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a0 @8 sd               ; protect a0
    rs1_sp rs2_a1 @16 sd              ; protect a1

    rd_a1 rs1_s9 mv                   ; Using output_list
    rd_ra $emit jal                   ; emit it
    rd_s9 rs1_a0 mv                   ; update it

    rd_ra rs1_sp ld                   ; restore ra
    rd_a0 rs1_sp !8 ld                ; restore a0
    rd_a1 rs1_sp !16 ld               ; restore a1
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; emit function
; Receives char *s in a0 and struct token_list* head in a1
; Returns struct token_list* T in a0
:emit
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a2 @8 sd               ; protect a2

    rd_a2 rs1_a0 mv                   ; Put S out of the way
    rd_a0 !40 addi                    ; sizeof(struct token_list)
    rd_ra $malloc jal                 ; get T
    rs1_a0 rs2_a1 sd                  ; t->next = head
    rs1_a0 rs2_a2 @16 sd              ; t->s = s

    rd_ra rs1_sp ld                   ; restore ra
    rd_a2 rs1_sp !8 ld                ; restore a2
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret


; type_name function
; Receives nothing
; Returns type_size in a0
; Uses a2 for STRUCT TYPE* RET
:type_name
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~struct auipc               ; Using "struct"
    rd_a0 rs1_a0 !struct addi
    rd_ra $match jal                  ; Check if global_token->S == "struct"
    rd_a2 rs1_a0 mv                   ; Protect structure
    rs1_a0 @type_name_native bnez     ; skip over "struct"

    ; Deal with possible STRUCTs
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a1 ~global_types auipc         ; get all known types
    rd_a1 rs1_a1 !global_types addi
    rd_a1 rs1_a1 ld                   ; Dereference pointer
    rd_ra $lookup_type jal            ; Find type if possible
    rd_a2 rs1_a0 mv                   ; Set ret

    rs1_a0 @type_name_common bnez     ; We have to create a struct if NULL == ret

    ; Create a struct
    rd_ra $create_struct jal          ; Create a new struct
    rd_a2 mv                          ; Return NULL
    $type_name_done jal               ; Done

:type_name_native
    ; Deal only with native types
    rd_a0 rs1_a1 mv                   ; Put global_token->S in the right place
    rd_a1 ~global_types auipc         ; get all known types
    rd_a1 rs1_a1 !global_types addi
    rd_a1 rs1_a1 ld                   ; Dereference pointer
    rd_ra $lookup_type jal            ; Find the type if possible
    rd_a2 rs1_a0 mv                   ; Set ret

    rs1_a0 @type_name_common bnez     ; Abort if NULL == ret

    ; Aborting hard
    rd_s3 !2 addi                     ; write to standard error
    rd_a0 ~type_name_string_0 auipc   ; "Print header"
    rd_a0 rs1_a0 !type_name_string_0 addi
    rd_ra $File_Print jal

    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_ra $File_Print jal             ; Print it

    rd_a0 ~type_name_string_1 auipc   ; "Print footer"
    rd_a0 rs1_a0 !type_name_string_1 addi
    rd_ra $File_Print jal             ; Print it

    $Fail jal                         ; Abort

:type_name_common
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

:type_name_iter
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !42 addi                    ; '*'
    rs1_a0 rs2_t0 @type_name_done bne ; recurse

    ; Deal with char**
    rd_a2 rs1_a2 !24 ld               ; ret = ret->indirect
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    $type_name_iter jal               ; keep looping

:type_name_done
    rd_a0 rs1_a2 mv                   ; put ret in the right place
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; lookup_type function
; Receives char* S in a0 and struct type* start in a1
; Returns struct type* in a0
; Uses a1 for S and a2 for I
:lookup_type
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a2 rs1_a1 mv                   ; I = Start
    rd_a1 rs1_a0 mv                   ; Put S in place

:lookup_type_iter
    rs1_a2 @lookup_type_done beqz     ; return NULL

    rd_a0 rs1_a2 !48 ld               ; I->NAME
    rd_ra $match jal                  ; Check if matching
    rs1_a0 @lookup_type_done beqz     ; Return it if I->NAME == S

    rd_a2 rs1_a2 ld                   ; Otherwise I = I->NEXT
    $lookup_type_iter jal             ; Keep looping

:lookup_type_done
    rd_a0 rs1_a2 mv                   ; return either I or NULL
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; create_struct function
; Receives nothing
; Returns nothing
; Uses global_token to malloc a struct's definition
; Uses a6 for int OFFSET, a2 for struct type* head, a3 for struct type* I,
; a4 for member_size (Which is passed) and a5 for LAST
; a0 and a1 are is used for scratch
:create_struct
    rd_sp rs1_sp !-56 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3
    rs1_sp rs2_a4 @32 sd              ; protect a4
    rs1_sp rs2_a5 @40 sd              ; protect a5
    rs1_sp rs2_a6 @48 sd              ; protect a6

    rd_a6 mv                          ; OFFSET = 0
    rd_a4 mv                          ; member_size = 0

    rd_a0 !56 addi                    ; sizeof(struct type)
    rd_ra $malloc jal                 ; malloc(sizeof(struct type))
    rd_a2 rs1_a0 mv                   ; Set HEAD

    rd_a0 !56 addi                    ; sizeof(struct type)
    rd_ra $malloc jal                 ; malloc(sizeof(struct type))
    rd_a3 rs1_a0 mv                   ; Set I

    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rs1_a2 rs2_a0 @48 sd              ; HEAD->NAME = global_token->S
    rs1_a3 rs2_a0 @48 sd              ; I->NAME = global_token->S

    rs1_a2 rs2_a3 @24 sd              ; HEAD->INDIRECT = I
    rs1_a3 rs2_a2 @24 sd              ; I->INDIRECT = HEAD

    rd_a0 ~global_types auipc         ; Using global_types
    rd_a0 rs1_a0 !global_types addi
    rd_a1 rs1_a0 ld                   ; Dereference pointer
    rs1_a2 rs2_a1 sd                  ; HEAD->NEXT = global_types
    rs1_a0 rs2_a2 sd                  ; global_types = HEAD

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 !8 addi                     ; Using register size
    rs1_a3 rs2_a0 @8 sd               ; I->SIZE = register size

    rd_a0 ~create_struct_string_0 auipc ; Using "ERROR in create_struct\n Missing {\n"
    rd_a0 rs1_a0 !create_struct_string_0 addi
    rd_a1 ~open_curly_brace auipc    ; Using "{"
    rd_a1 rs1_a1 !open_curly_brace addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_a5 mv                          ; LAST = NULL

:create_struct_iter
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !125 addi                   ; "}"
    rs1_a0 rs2_t0 @create_struct_done beq ; We are done

    rd_a0 rs1_a5 mv                   ; put last in right place
    rd_a1 rs1_a6 mv                   ; put offset in right place
    rd_ra $build_member jal           ; ASSEMBLE
:create_struct_common
    rd_a5 rs1_a0 mv                   ; last = build_member(last, offset)
    rd_a6 rs1_a6 rs2_a4 add           ; offset = offset + member_size

    rd_a0 ~create_struct_string_1 auipc ; Using "ERROR in create_struct\n Missing ;\n"
    rd_a0 rs1_a0 !create_struct_string_1 addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Make sure we have it
    $create_struct_iter jal           ; Keep going

:create_struct_done
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    rd_a0 ~create_struct_string_1 auipc ; Using "ERROR in create_struct\n Missing ;\n"
    rd_a0 rs1_a0 !create_struct_string_1 addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Make sure we have it

    rs1_a2 rs2_a6 @8 sd               ; HEAD->SIZE = OFFSET
    rs1_a2 rs2_a5 @32 sd              ; HEAD->MEMBERS = LAST
    rs1_a3 rs2_a5 @32 sd              ; I->MEMBERS = LAST

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_a4 rs1_sp !32 ld               ; restore a4
    rd_a5 rs1_sp !40 ld               ; restore a5
    rd_a6 rs1_sp !48 ld               ; restore a6
    rd_sp rs1_sp !56 addi             ; deallocate stack
    ret


; lookup_member function
; Receives struct type* parent in a0 and char* name in a1
; Returns struct type* I in a0
; Uses char* NAME in a1, a2 for struct type* I and a3 to hold parent for errors
; Aborts hard if not found
:lookup_member
    rd_sp rs1_sp !-32 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3

    rd_a3 rs1_a0 mv                   ; Protect Parent
    rd_a2 rs1_a0 !32 ld               ; struct type* I = parent->MEMBERS

:lookup_member_iter
    rs1_a2 @lookup_member_fail beqz   ; Abort HARD IF I == NULL

    rd_a0 rs1_a2 !48 ld               ; Using I->NAME
    rd_ra $match jal                  ; IF I->NAME == NAME
    rd_t0 rs1_a0 mv                   ; Protect result
    rd_a0 rs1_a2 mv                   ; Prepare for return
    rd_a2 rs1_a2 !32 ld               ; Prepare for loop I = I->MEMBERS
    rs1_t0 @lookup_member_iter bnez   ; Looks like we are looping

    ; I is aready in a0
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_sp rs1_sp !32 addi             ; deallocate stack
    ret

:lookup_member_fail
    rd_s3 !2 addi                     ; write to standard error
    rd_a0 ~lookup_member_string_0 auipc ; Using "ERROR in lookup_member "
    rd_a0 rs1_a0 !lookup_member_string_0 addi
    rd_ra $File_Print jal             ; print it

    rd_a0 rs1_a3 !48 ld               ; PARENT->NAME
    rd_ra $File_Print jal             ; print it

    rd_a1 rs1_s4 !16 ld               ; global_token->S

    rd_a0 ~lookup_member_string_1 auipc ; Using " does not exist\n"
    rd_a0 rs1_a0 !lookup_member_string_1 addi
    rd_ra $File_Print jal             ; print it

    rd_a0 ~lookup_member_string_2 auipc ; Using "\n"
    rd_a0 rs1_a0 !lookup_member_string_2 addi
    rd_ra $File_Print jal             ; print it
    $Fail jal                         ; Abort Hard


; build_member function
; Receives struct type* last in a0, int offset in a1 and global member_size in a4
; Updates member_size in a4 and returns struct type* I in a0
; Uses a2 for struct type* member_type and a3 for struct type* I
:build_member
    rd_sp rs1_sp !-32 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3

    rd_a3 rs1_a0 mv                   ; Put last out of the way
    rd_a0 !56 addi                    ; Allocate type
    rd_ra $malloc jal                 ; Get I
    rs1_a0 rs2_a3 @32 sd              ; I->MEMBERS = LAST
    rs1_a0 rs2_a1 @16 sd              ; I->OFFSET = OFFSET
    rd_a3 rs1_a0 mv                   ; Put I in place

    rd_ra $type_name jal              ; Get member_type
    rd_a2 rs1_a0 mv                   ; Put in place
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rs1_a3 rs2_a1 @48 sd              ; I->NAME = global_token->S
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    ; Check if we have an array
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~open_bracket auipc         ; Using "["
    rd_a0 rs1_a0 !open_bracket addi
    rd_ra $match jal                  ; If global_token->S == "["
    rs1_a0 $build_member_array beqz   ; Then we have to deal with arrays in our struct

    ; Deal with non-array case
    rd_a0 rs1_a2 !8 ld                ; member_type->SIZE
    rs1_a3 rs2_a0 @8 sd               ; I->SIZE = member_type->SIZE
    $build_member_done jal            ; We are done

:build_member_array
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_ra $numerate_string jal        ; convert number
    rd_a1 rs1_a2 !40 ld               ; member_type->TYPE
    rd_a1 rs1_a1 !8 ld                ; member_type->TYPE->SIZE
    rd_a0 rs1_a0 rs2_a1 mul           ; member_type->type->size * numerate_string(global_token->s)

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 ~build_member_string_0 auipc ; Using "Struct only supports [num] form\n"
    rd_a0 rs1_a0 !build_member_string_0 addi
    rd_a1 ~close_bracket auipc        ; Using "]"
    rd_a1 rs1_a1 !close_bracket addi
    rd_ra $require_match jal          ; Make sure we have it

:build_member_done
    rd_a4 rs1_a3 !8 ld                ; MEMBER_SIZE = I->SIZE
    rs1_a3 rs2_a2 @40 sd              ; I->TYPE = MEMBER_TYPE
    rd_a0 rs1_a3 mv                   ; Return I

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_sp rs1_sp !32 addi             ; deallocate stack
    ret


; require_match function
; Receives char* message in a0 and char* required in a1
; Returns nothing
; Uses a2 to hold message and updates global_token
:require_match
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a2 rs1_a0 mv                   ; put the message somewhere safe
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_ra $match jal                  ; IF required == global_token->S
    rs1_a0 @require_match_good beqz   ; otherwise print error

    ; Deal with bad times
    rd_s3 !2 addi                     ; write to standard error
    rd_a0 rs1_a2 mv                   ; using out message
    rd_ra $File_Print jal             ; Print it
    $Fail jal                         ; Abort HARD

:require_match_good
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; uniqueID Function
; Receives char *S in a0, struct token_list* l in a1 and char* num in a2
; Returns updated struct token_list* L in a0
:uniqueID
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_ra $emit jal                   ; emit(s, l)
    rd_a1 rs1_a0 mv                   ; Put L in correct place
    rd_a0 ~underline auipc            ; Using "_"
    rd_a0 rs1_a0 !underline addi
    rd_ra $emit jal                   ; emit("_", l)
    rd_a1 rs1_a0 mv                   ; Put L in correct place
    rd_a0 rs1_a2 mv                   ; Put num in correct place
    rd_ra $emit jal                   ; emit(num, l)
    rd_a1 rs1_a0 mv                   ; Put L in correct place
    rd_a0 ~uniqueID_string_0 auipc    ; Using "\n"
    rd_a0 rs1_a0 !uniqueID_string_0 addi
    rd_ra $emit jal                   ; emit("\n", l)

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; uniqueID_out function
; Receives char* S in a0 and char* num in a1
; Returns nothing
:uniqueID_out
    rd_sp rs1_sp !-32 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a0 @8 sd               ; protect a0
    rs1_sp rs2_a1 @16 sd              ; protect a1
    rs1_sp rs2_a2 @24 sd              ; protect a2

    rd_a2 rs1_a1 mv                   ; Put num in right spot
    rd_a1 rs1_s9 mv                   ; Using output_list
    rd_ra $uniqueID jal               ; Get updated list
    rd_s9 rs1_a0 mv                   ; output_list = uniqueID(s, output_list, num)

    rd_ra rs1_sp ld                   ; restore ra
    rd_a0 rs1_sp !8 ld                ; restore a0
    rd_a1 rs1_sp !16 ld               ; restore a1
    rd_a2 rs1_sp !24 ld               ; restore a2
    rd_sp rs1_sp !32 addi             ; deallocate stack
    ret


; declare_function function
; Receives nothing and returns nothing
; Sets current function and adds it to the global function list
:declare_function
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_s10 mv                         ; current_count = 0
    rd_a0 rs1_s4 !8 ld                ; global_token->prev
    rd_a0 rs1_a0 !16 ld               ; global_token->prev->s
    rd_a1 mv                          ; NULL
    rd_a2 rs1_s8 mv                   ; global_function_list
    rd_ra $sym_declare jal            ; sym_declare(global_token->prev->s, NULL, global_function_list);
    rd_s11 rs1_a0 mv                  ; function = sym_declare(global_token->prev->s, NULL, global_function_list);
    rd_s8 rs1_a0 mv                   ; global_function_list = function

    rd_ra $collect_arguments jal      ; collect all of the function arguments

    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a1 ~semicolon auipc            ; ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $match jal                  ; If global_token->s == ";"
    rs1_a0 @declare_function_full bnez ; then it is a function prototype

    ; Deal with prototypes
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    $declare_function_done jal        ; Move on

:declare_function_full
    ; Deal with full function definitions
    rd_a0 ~declare_function_string_0 auipc ; "# Defining function "
    rd_a0 rs1_a0 !declare_function_string_0 addi
    rd_ra $emit_out jal               ; emit it

    rd_a0 rs1_s11 !16 ld              ; function->s
    rd_ra $emit_out jal               ; emit it

    rd_a0 ~declare_function_string_1 auipc ; "\n:FUNCTION_"
    rd_a0 rs1_a0 !declare_function_string_1 addi
    rd_ra $emit_out jal               ; emit it

    rd_a0 rs1_s11 !16 ld              ; function->s
    rd_ra $emit_out jal               ; emit it

    rd_a0 ~declare_function_string_3 auipc ; "\n"
    rd_a0 rs1_a0 !declare_function_string_3 addi
    rd_ra $emit_out jal               ; emit it

    rd_ra $statement jal              ; Recursively get the function pieces

    rd_a0 rs1_s9 !16 ld               ; output->s
    rd_a1 ~declare_function_string_2 auipc ; "ret\n"
    rd_a1 rs1_a1 !declare_function_string_2 addi
    rd_ra $match jal                  ; If output->s == "ret\n"
    rs1_a0 @declare_function_done beqz ; Then skip adding it

    ; Add the return to the end of a function lacking a return
    rd_a0 ~declare_function_string_2 auipc ; "ret\n"
    rd_a0 rs1_a0 !declare_function_string_2 addi
    rd_ra $emit_out jal               ; emit it

:declare_function_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; collect_arguments function
; Receives nothing
; Returns Nothing
; Adds arguments to the function definition
; holds struct type* type_size in a2, then replace with struct token_list* A in a2 when type_size is used
:collect_arguments
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
:collect_arguments_loop
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~close_paren auipc          ; ")"
    rd_a0 rs1_a0 !close_paren addi
    rd_ra $match jal                  ; IF global_token->S == ")"
    rs1_a0 @collect_arguments_done beqz ; then we are done

    ; deal with the case of there are arguments
    rd_ra $type_name jal              ; Get the type
    rd_a2 rs1_a0 mv                   ; put type_size safely out of the way

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~close_paren auipc          ; ")"
    rd_a0 rs1_a0 !close_paren addi
    rd_ra $match jal                  ; IF global_token->S == ")"
    rs1_a0 @collect_arguments_common beqz ; is a foo(int, char,void) case

    ; Trying second else
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~comma auipc                ; ","
    rd_a0 rs1_a0 !comma addi
    rd_ra $match jal                  ; IF global_token->S == ","
    rs1_a0 @collect_arguments_common beqz ; then deal with commas between arguments

    ; deal with foo(int a, char b)
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a1 rs1_a2 mv                   ; put type_size in the right place
    rd_a2 rs1_s11 !32 ld              ; function->args
    rd_ra $sym_declare jal            ; sym_declare(global_token->s, type_size, function->arguments)
    rd_a2 rs1_a0 mv                   ; put A in a safe place

    rd_a0 rs1_s11 !32 ld              ; function->args
    rs1_a0 @collect_arguments_another bnez ; Check if it's the first argument (IF function->args == NULL)

    ; Deal with the case of first argument in the function
    rd_t0 !8 addi                     ; 8
    rs1_a2 rs2_t0 @32 sd              ; a->depth = 8
    $collect_arguments_next jal       ; get to next

:collect_arguments_another
    rd_a0 rs1_s11 !32 ld              ; function->args
    rd_a0 rs1_a0 !32 ld               ; function->args->depth
    rd_a0 rs1_a0 !8 addi              ; function->args->depth + 8
    rs1_a2 rs2_a0 @32 sd              ; a->depth = function->args->depth + 8

:collect_arguments_next
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    rs1_s11 rs2_a2 @32 sd             ; function->args = a

:collect_arguments_common
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~comma auipc                ; ","
    rd_a0 rs1_a0 !comma addi
    rd_ra $match jal                  ; IF global_token->S == ","
    rs1_a0 @collect_arguments_loop bnez ; then deal with comma, else loop

    ; keep foo(bar(), 1) expressions working
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    $collect_arguments_loop jal       ; keep going

:collect_arguments_done
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; statement function
; Receives nothing
; Returns nothing
; Walks down global_token recursively to collect the contents of the function
:statement
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~open_curly_brace auipc     ; "{"
    rd_a0 rs1_a0 !open_curly_brace addi
    rd_ra $match jal                  ; IF global_token->S == "{"
    rs1_a0 @statement_label bnez      ; otherwise try label

    ; deal with { statement }
    rd_ra $recursive_statement jal    ; Statements inside of statements for days
    $statement_done jal               ; We are done

:statement_label
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !58 addi                    ; Check if global_token->S == ':'
    rs1_a0 rs2_t0 @statement_local bne ; otherwise try locals

    ; deal with labels
    rd_a0 rs1_a1 mv                   ; put global_token->S in the right spot
    rd_ra $emit_out jal               ; emit it

    rd_a0 ~statement_string_0 auipc   ; Using "\t#C goto label\n"
    rd_a0 rs1_a0 !statement_string_0 addi
    rd_ra $emit_out jal               ; emit it

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    $statement_done jal               ; We are done

:statement_local
    rd_a0 rs1_a1 mv                   ; put global_token->S in the right place
    rd_a1 ~prim_types auipc           ; pointer to primitive types
    rd_a1 rs1_a1 !prim_types addi
    rd_ra $lookup_type jal            ; See if found
    rs1_a0 @statement_local_success bnez ; Collect new local

    ; Second chance
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~struct auipc               ; "struct"
    rd_a0 rs1_a0 !struct addi
    rd_ra $match jal                  ; IF global_token->S == "struct"
    rs1_a0 @statement_if bnez         ; then we have a new local, otherwise try IF

:statement_local_success
    rd_ra $collect_local jal          ; Grab those locals
    $statement_done jal               ; We are done

:statement_if
    rd_a0 ~if_string auipc            ; Using "if"
    rd_a0 rs1_a0 !if_string addi
    rd_ra $match jal                  ; IF global_token->S == "if"
    rs1_a0 @statement_do bnez         ; then we have a if statement, else try do

    ; Deal with IF statement
    rd_ra $process_if jal             ; Process if
    $statement_done jal               ; We are done

:statement_do
    rd_a0 ~do_string auipc            ; Using "do"
    rd_a0 rs1_a0 !do_string addi
    rd_ra $match jal                  ; IF global_token->S == "do"
    rs1_a0 @statement_while bnez      ; then we have a do statement, else try while

    ; Deal with DO statement
    rd_ra $process_do jal             ; Process do
    $statement_done jal               ; We are done

:statement_while
    rd_a0 ~while_string auipc         ; Using "while"
    rd_a0 rs1_a0 !while_string addi
    rd_ra $match jal                  ; IF global_token->S == "while"
    rs1_a0 @statement_for bnez        ; then we have a while statement, else try for

    ; Deal with WHILE statement
    rd_ra $process_while jal          ; Process while
    $statement_done jal               ; We are done

:statement_for
    rd_a0 ~for_string auipc           ; Using "for"
    rd_a0 rs1_a0 !for_string addi
    rd_ra $match jal                  ; IF global_token->S == "for"
    rs1_a0 @statement_asm bnez        ; then we have a for statement, else try asm

    ; Deal with FOR statement
    rd_ra $process_for jal            ; Process for
    $statement_done jal               ; We are done

:statement_asm
    rd_a0 ~asm_string auipc           ; Using "asm"
    rd_a0 rs1_a0 !asm_string addi
    rd_ra $match jal                  ; IF global_token->S == "asm"
    rs1_a0 @statement_goto bnez       ; then we have a asm statement, else try goto

    ; Deal with ASM statement
    rd_ra $process_asm jal            ; Process asm
    $statement_done jal               ; We are done

:statement_goto
    rd_a0 ~goto_string auipc          ; Using "goto"
    rd_a0 rs1_a0 !goto_string addi
    rd_ra $match jal                  ; IF global_token->S == "goto"
    rs1_a0 @statement_return bnez     ; then we have a goto statement, else try return

    ; Deal with GOTO statement
    rd_a0 ~statement_string_1 auipc   ; Using "$"
    rd_a0 rs1_a0 !statement_string_1 addi
    rd_ra $emit_out jal               ; emit it

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_ra $emit_out jal               ; emit it

    ; Deal with GOTO statement
    rd_a0 ~statement_string_2 auipc   ; Using " jal\n"
    rd_a0 rs1_a0 !statement_string_2 addi
    rd_ra $emit_out jal               ; emit it

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 ~statement_string_4 auipc   ; Using "ERROR in statement\nMissing ;\n"
    rd_a0 rs1_a0 !statement_string_4 addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Make sure we have it
    $statement_done jal               ; We are done

:statement_return
    rd_a0 ~return_string auipc        ; Using "return"
    rd_a0 rs1_a0 !return_string addi
    rd_ra $match jal                  ; IF global_token->S == "return"
    rs1_a0 @statement_break bnez      ; then we have a return statement, else try break

    ; Deal with ret statement
    rd_ra $return_result jal          ; Return anything they want
    $statement_done jal               ; We are done

:statement_break
    rd_a0 ~break_string auipc         ; Using "break"
    rd_a0 rs1_a0 !break_string addi
    rd_ra $match jal                  ; IF global_token->S == "break"
    rs1_a0 @statement_continue bnez   ; then we have a return break, else try continue

    ; Deal with BREAK statement
    rd_ra $process_break jal          ; Process break
    $statement_done jal               ; We are done

:statement_continue
    rd_a0 ~continue_string auipc      ; Using "continue"
    rd_a0 rs1_a0 !continue_string addi
    rd_ra $match jal                  ; IF global_token->S == "continue"
    rs1_a0 @statement_else bnez       ; then we have a continue statement, else we are punting to an expression

    ; Deal with CONTINUE statement
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 ~statement_string_3 auipc   ; Using "\n#continue statement\n"
    rd_a0 rs1_a0 !statement_string_3 addi
    rd_ra $emit_out jal               ; emit it

    rd_a0 ~statement_string_4 auipc   ; Using "ERROR in statement\nMissing ;\n"
    rd_a0 rs1_a0 !statement_string_4 addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Make sure we have it
    $statement_done jal               ; We are done

:statement_else
    rd_ra $expression jal             ; Collect expression
    rd_a0 ~statement_string_4 auipc   ; Using "ERROR in statement\nMissing ;\n"
    rd_a0 rs1_a0 !statement_string_4 addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Make sure we have it

:statement_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; recursive_statement function
; Receives nothing
; Returns nothing
; Walks the global_token list to build the contents of statements
; Uses struct token_list* frame in a2
:recursive_statement
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    rd_a2 rs1_s11 !8 ld               ; frame = function->locals

:recursive_statement_loop
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~close_curly_brace auipc    ; "}"
    rd_a0 rs1_a0 !close_curly_brace addi
    rd_ra $match jal                  ; IF global_token->S == "}"
    rs1_a0 @recursive_statement_cleanup beqz ; then we are done recursing

    ; Deal with recursive calls
    rd_ra $statement jal              ; Deal with another statement
    $recursive_statement_loop jal     ; keep looping

:recursive_statement_cleanup
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    rd_a0 ~recursive_statement_string_0 auipc ; Using "ret\n"
    rd_a0 rs1_a0 !recursive_statement_string_0 addi
    rd_a1 rs1_s9 !16 ld               ; output->S
    rd_ra $match jal                  ; IF output->S == "ret\n"
    rs1_a0 @recursive_statement_done beqz ; We are done

    ;; Deal with cleanup
    rd_a1 rs1_s11 !8 ld               ; i = function->locals
    rd_a0 ~recursive_statement_string_1 auipc ; Using "rd_a1 rs1_sp ld	# _recursive_statement_locals..."
    rd_a0 rs1_a0 !recursive_statement_string_1 addi

:recursive_statement_locals
    rs1_a1 rs2_a2 @recursive_statement_done beq ; Check if frame != i

    ; Let's emit
    rd_ra $emit_out jal               ; emit it
    rd_a1 rs1_a1 ld                   ; i = i->next
    $recursive_statement_locals jal   ; keep going

:recursive_statement_done
    rs1_s11 rs2_a2 @8 sd              ; function->locals = frame

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; collect_local function
; Receives nothing
; Returns nothing
; Walks global_token list to create function locals
; Uses a2 for struct token_list* A
:collect_local
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_ra $type_name jal              ; Get the local's type

    rd_a1 rs1_a0 mv                   ; Put struct type* type_size in the right place
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a2 rs1_s11 !8 ld               ; function->locals
    rd_ra $sym_declare jal            ; Declare it
    rd_a2 rs1_a0 mv                   ; put it away safely

    ; Try for main
    rd_a0 ~main_string auipc          ; Using "main"
    rd_a0 rs1_a0 !main_string addi
    rd_a1 rs1_s11 !16 ld              ; function->S
    rd_ra $match jal                  ; IF match("main", function->s)
    rs1_a0 @collect_local_fresh bnez  ; try to see if fresh function

    ; Ok we are in main, now to see if main is fresh
    rd_a0 rs1_s11 !8 ld               ; function->locals
    rs1_a0 @collect_local_fresh bnez  ; try to see if fresh function

    ; Sweet we are in a fresh main
    rd_a0 !32 addi                    ; Start at 32
    rs1_a2 rs2_a0 @32 sd              ; a->DEPTH = 32
    $collect_local_common jal         ; Go to the commons

:collect_local_fresh
    rd_a0 rs1_s11 !32 ld              ; function->args
    rs1_a0 @collect_local_first bnez  ; Otherwise see if first

    rd_a0 rs1_s11 !8 ld               ; function->locals
    rs1_a0 @collect_local_first bnez  ; Otherwise try first

    ; Sweet we are in a fresh function
    rd_a0 !8 addi                     ; We start at 8
    rs1_a2 rs2_a0 @32 sd              ; a->DEPTH = 8
    $collect_local_common jal         ; Go to the commons

:collect_local_first
    rd_a0 rs1_s11 !8 ld               ; function->locals
    rs1_a0 @collect_local_else bnez   ; Looks like we are just another local

    ; Ok we are the first local
    rd_a0 rs1_s11 !32 ld              ; function->args
    rd_a0 rs1_a0 !32 ld               ; function->args->depth
    rd_a0 rs1_a0 !8 addi              ; function->arguments->depth + 8
    rs1_a2 rs2_a0 @32 sd              ; a->DEPTH = function->arguments->depth + 8
    $collect_local_common jal         ; Go to the commons

:collect_local_else
    ; Always the last to know
    rd_a0 rs1_s11 !8 ld               ; function->locals
    rd_a0 rs1_a0 !32 ld               ; function->locals->depth
    rd_a0 rs1_a0 !8 addi              ; function->locals->depth + 8
    rs1_a2 rs2_a0 @32 sd              ; a->DEPTH = function->locals->depth + 8

:collect_local_common
    rs1_s11 rs2_a2 @8 sd              ; function->locals = a
    rd_a2 rs1_a2 !16 ld               ; a->S

    rd_a0 ~collect_local_string_0 auipc ; Using "# Defining local "
    rd_a0 rs1_a0 !collect_local_string_0 addi
    rd_ra $emit_out jal               ; emit it

    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_ra $emit_out jal               ; emit it

    rd_a0 ~collect_local_string_1 auipc ; Using "\n"
    rd_a0 rs1_a0 !collect_local_string_1 addi
    rd_ra $emit_out jal               ; emit it

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~equal auipc                ; Using "="
    rd_a0 rs1_a0 !equal addi
    rd_ra $match jal                  ; IF match("=", global_token->s)
    rs1_a0 @collect_local_done bnez   ; Deal with assignment, else finish it

    ; Deal with assignment
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_ra $expression jal             ; Recurse

:collect_local_done
    rd_a0 ~collect_local_string_2 auipc ; Using "ERROR in collect_local\nMissing ;\n"
    rd_a0 rs1_a0 !collect_local_string_2 addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_a0 ~collect_local_string_3 auipc ; Using "rd_sp rs1_sp !-8 addi\nrs1_sp rs2_a0 sd\t#"
    rd_a0 rs1_a0 !collect_local_string_3 addi
    rd_ra $emit_out jal               ; emit it

    rd_a0 rs1_a2 mv                   ; Put A->S where it belongs
    rd_ra $emit_out jal               ; emit it

    rd_a0 ~collect_local_string_1 auipc ; Using "\n"
    rd_a0 rs1_a0 !collect_local_string_1 addi
    rd_ra $emit_out jal               ; emit it

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; process_if function
; Receives nothing
; Returns Nothing
; Increments current_count recurses into expression + statement
; Uses a2 for char* NUMBER_STRING
:process_if
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a0 rs1_s10 mv                  ; Get current_count
    rd_s10 rs1_s10 !1 addi            ; current_count = current_count + 1
    rd_ra $numerate_number jal        ; convert to string
    rd_a2 rs1_a0 mv                   ; put NUMBER_STRING in place

    rd_a0 ~process_if_string_0 auipc  ; Using "# IF_"
    rd_a0 rs1_a0 !process_if_string_0 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 ~process_if_string_1 auipc  ; Using "ERROR in process_if\nMISSING (\n"
    rd_a0 rs1_a0 !process_if_string_1 addi
    rd_a1 ~open_paren auipc           ; Using "("
    rd_a1 rs1_a1 !open_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_ra $expression jal             ; Recurse to get the IF(...) part

    rd_a0 ~process_if_string_2 auipc  ; Using "rs1_a0 @8 bnez\n$ELSE_"
    rd_a0 rs1_a0 !process_if_string_2 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_if_string_2a auipc ; Using "jal\n"
    rd_a0 rs1_a0 !process_if_string_2a addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~process_if_string_3 auipc  ; Using "ERROR in process_do\nMISSING )\n"
    rd_a0 rs1_a0 !process_if_string_3 addi
    rd_a1 ~close_paren auipc          ; Using ")"
    rd_a1 rs1_a1 !close_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_ra $statement jal              ; Recursive to get the IF(){...} part

    rd_a0 ~process_if_string_4 auipc  ; Using "$_END_IF_"
    rd_a0 rs1_a0 !process_if_string_4 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_if_string_5 auipc  ; Using "jal\n:ELSE_"
    rd_a0 rs1_a0 !process_if_string_5 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~else_string auipc          ; Using "else"
    rd_a0 rs1_a0 !else_string addi
    rd_ra $match jal                  ; IF global_token->S == "else"
    rs1_a0 @process_if_done bnez      ; Then we need to collect the else too, otherwise done

    ; deal with else statement
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_ra $statement jal              ; Recurse to get the ELSE {...} part

:process_if_done
    rd_a0 ~process_if_string_6 auipc  ; Using ":_END_IF_"
    rd_a0 rs1_a0 !process_if_string_6 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; process_do function
; Receives Nothing
; Returns Nothing
; Increments current_count and leverages save/restore_break_frame pieces
; Uses a2 for char* NUMBER_STRING
:process_do
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_ra $save_break_frame jal       ; Save the frame
    rd_a0 rs1_s10 mv                  ; Get current_count
    rd_s10 rs1_s10 !1 addi            ; current_count = current_count + 1
    rd_ra $numerate_number jal        ; convert to string
    rd_a2 rs1_a0 mv                   ; put NUMBER_STRING in place

    rd_a0 ~process_do_string_0 auipc  ; Using "DO_END_"
    rd_a0 rs1_a0 !process_do_string_0 addi
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $set_break_frame jal        ; Set the frame

    rd_a0 ~process_do_string_1 auipc  ; Using ":DO_"
    rd_a0 rs1_a0 !process_do_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_ra $statement jal              ; Do the DO {...} part

    rd_a0 ~process_do_string_2 auipc  ; Using "ERROR in process_do\nMISSING while\n"
    rd_a0 rs1_a0 !process_do_string_2 addi
    rd_a1 ~while_string auipc         ; Using "while"
    rd_a1 rs1_a1 !while_string addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_a0 ~process_do_string_3 auipc  ; Using "ERROR in process_do\nMISSING (\n"
    rd_a0 rs1_a0 !process_do_string_3 addi
    rd_a1 ~open_paren auipc           ; Using "("
    rd_a1 rs1_a1 !open_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_ra $expression jal             ; Do the WHILE (...) part

    rd_a0 ~process_do_string_4 auipc  ; Using "ERROR in process_do\nMISSING )\n"
    rd_a0 rs1_a0 !process_do_string_4 addi
    rd_a1 ~close_paren auipc          ; Using ")"
    rd_a1 rs1_a1 !close_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_a0 ~process_do_string_5 auipc  ; Using "ERROR in process_do\nMISSING ;\n"
    rd_a0 rs1_a0 !process_do_string_5 addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_a0 ~process_do_string_6 auipc  ; Using "rs1_a0 @DO_END_"
    rd_a0 rs1_a0 !process_do_string_6 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_do_string_6a auipc ; Using "beqz\n$DO_"
    rd_a0 rs1_a0 !process_do_string_6a addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_do_string_7 auipc  ; Using "jal\n:DO_END_"
    rd_a0 rs1_a0 !process_do_string_7 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_ra $restore_break_frame jal    ; Restore the old break frame

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; process_while function
; Receives nothing
; Returns nothing
; Increments current_count and leverages save/restore_break_frame pieces
; Uses a2 for char* NUMBER_STRING
:process_while
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_ra $save_break_frame jal       ; Save the frame
    rd_a0 rs1_s10 mv                  ; Get current_count
    rd_s10 rs1_s10 !1 addi            ; current_count = current_count + 1
    rd_ra $numerate_number jal        ; convert to string
    rd_a2 rs1_a0 mv                   ; put NUMBER_STRING in place

    rd_a0 ~process_while_string_0 auipc ; Using "END_WHILE_"
    rd_a0 rs1_a0 !process_while_string_0 addi
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $set_break_frame jal        ; Set it and forget it

    rd_a0 ~process_while_string_1 auipc ; Using ":WHILE_"
    rd_a0 rs1_a0 !process_while_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 ~process_while_string_2 auipc ; Using "ERROR in process_while\nMISSING (\n"
    rd_a0 rs1_a0 !process_while_string_2 addi
    rd_a1 ~open_paren auipc           ; Using "("
    rd_a1 rs1_a1 !open_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_ra $expression jal             ; Deal with the WHILE (...) part

    rd_a0 ~process_while_string_3 auipc ; Using "rs1_a0 @8 bnez\n$END_WHILE_"
    rd_a0 rs1_a0 !process_while_string_3 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_while_string_4 auipc ; Using "jal\n# THEN_while_"
    rd_a0 rs1_a0 !process_while_string_4 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_while_string_5 auipc ; Using "ERROR in process_while\nMISSING )\n"
    rd_a0 rs1_a0 !process_while_string_5 addi
    rd_a1 ~close_paren auipc           ; Using ")"
    rd_a1 rs1_a1 !close_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_ra $statement jal              ; Deal with the {....} part

    rd_a0 ~process_while_string_6 auipc ; Using "$WHILE_"
    rd_a0 rs1_a0 !process_while_string_6 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_while_string_7 auipc ; Using "jal\n:END_WHILE_"
    rd_a0 rs1_a0 !process_while_string_7 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_ra $restore_break_frame jal    ; Restore the old break frame

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; process_for function
; Receives Nothing
; Returns Nothing
; Increments current_count and leverages save/restore_break_frame pieces
; Uses a2 for char* NUMBER_STRING
:process_for
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_ra $save_break_frame jal       ; Save the frame
    rd_a0 rs1_s10 mv                  ; Get current_count
    rd_s10 rs1_s10 !1 addi            ; current_count = current_count + 1
    rd_ra $numerate_number jal        ; convert to string
    rd_a2 rs1_a0 mv                   ; put NUMBER_STRING in place

    rd_a0 ~process_for_string_0 auipc ; Using "FOR_END_"
    rd_a0 rs1_a0 !process_for_string_0 addi
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $set_break_frame jal        ; Set it and forget it

    rd_a0 ~process_for_string_1 auipc ; Using "# FOR_initialization_"
    rd_a0 rs1_a0 !process_for_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 ~process_for_string_2 auipc ; Using "ERROR in process_for\nMISSING (\n"
    rd_a0 rs1_a0 !process_for_string_2 addi
    rd_a1 ~open_paren auipc           ; Using "("
    rd_a1 rs1_a1 !open_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~semicolon auipc            ; Using ";"
    rd_a0 rs1_a0 !semicolon addi
    rd_ra $match jal                  ; IF global_token->S == ";"
    rs1_a0 @process_for_terminator beqz ; Then no initializer, skip getting the expression

    ; Deal with FOR (...; case
    rd_ra $expression jal             ; Get the FOR ( ... ; part

:process_for_terminator
    rd_a0 ~process_for_string_3 auipc ; Using ":FOR_"
    rd_a0 rs1_a0 !process_for_string_3 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_for_string_4 auipc ; Using "ERROR in process_for\nMISSING ;1\n"
    rd_a0 rs1_a0 !process_for_string_4 addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_ra $expression jal             ; Get the FOR ( ; ... ; Part

    rd_a0 ~process_for_string_5 auipc ; Using "rs1_a0 @8 bnez\n$FOR_END_"
    rd_a0 rs1_a0 !process_for_string_5 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_for_string_6 auipc ; Using "jal\n$FOR_THEN_"
    rd_a0 rs1_a0 !process_for_string_6 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_for_string_7 auipc ; Using "jal\n:FOR_ITER_"
    rd_a0 rs1_a0 !process_for_string_7 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_for_string_8 auipc ; Using "ERROR in process_for\nMISSING ;2\n"
    rd_a0 rs1_a0 !process_for_string_8 addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_ra $expression jal             ; Get the FOR (;;...) part

    rd_a0 ~process_for_string_9 auipc ; Using "$FOR_"
    rd_a0 rs1_a0 !process_for_string_9 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_for_string_10 auipc ; Using "jal\n:FOR_THEN_"
    rd_a0 rs1_a0 !process_for_string_10 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_for_string_11 auipc ; Using "ERROR in process_for\nMISSING )\n"
    rd_a0 rs1_a0 !process_for_string_11 addi
    rd_a1 ~close_paren auipc          ; Using ")"
    rd_a1 rs1_a1 !close_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_ra $statement jal              ; Get FOR (;;) {...} part

    rd_a0 ~process_for_string_12 auipc ; Using "$FOR_ITER_"
    rd_a0 rs1_a0 !process_for_string_12 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~process_for_string_13 auipc ; Using "jal\n:FOR_END_"
    rd_a0 rs1_a0 !process_for_string_13 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_ra $restore_break_frame jal    ; Restore the old break frame

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; process_asm function
; Receives nothing
; Returns nothing
; Simply inlines the asm statements
; Uses a1 for global_token temp storage
:process_asm
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 ~process_asm_string_0 auipc ; Using "ERROR in process_asm\nMISSING (\n"
    rd_a0 rs1_a0 !process_asm_string_0 addi
    rd_a1 ~open_paren auipc           ; Using "("
    rd_a1 rs1_a1 !open_paren addi
    rd_ra $require_match jal          ; Make sure we have it

:process_asm_iter
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !34 addi                    ; IF global_token->S[0] == '"'
    rs1_a0 rs2_t0 @process_asm_done bne ; Otherwise be done

    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 !1 addi              ; global_token->S + 1
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~process_asm_string_1 auipc ; Using "\n"
    rd_a0 rs1_a0 !process_asm_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    $process_asm_iter jal             ; keep going

:process_asm_done
    rd_a0 ~process_asm_string_2 auipc ; Using "ERROR in process_asm\nMISSING )\n"
    rd_a0 rs1_a0 !process_asm_string_2 addi
    rd_a1 ~close_paren auipc          ; Using ")"
    rd_a1 rs1_a1 !close_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_a0 ~process_asm_string_3 auipc ; Using "ERROR in process_asm\nMISSING ;\n"
    rd_a0 rs1_a0 !process_asm_string_3 addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret


; return_result function
; Receives nothing
; Returns nothing
; Cleans up function and generates return
; Also handles returning expressions
:return_result
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !59 addi                    ; ';'
    rs1_a0 rs2_t0 @return_result_cleanup beq ; Go straight to cleanup

    rd_ra $expression jal             ; get the expression we are returning

:return_result_cleanup
    rd_a0 ~return_result_string_0 auipc ; Using "ERROR in return_result\nMISSING ;\n"
    rd_a0 rs1_a0 !return_result_string_0 addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_a1 rs1_s11 !8 ld               ; i = function->locals
    rd_a0 ~return_result_string_1 auipc ; Using "rd_a1 rs1_sp ld\t# _return_result_locals..."
    rd_a0 rs1_a0 !return_result_string_1 addi

:return_result_locals
    rs1_a1 @return_result_done beqz   ; We are done if NULL == i

    rd_ra $emit_out jal               ; Emit out pop
    rd_a1 rs1_a1 ld                   ; i = i->NEXT
    $return_result_locals jal         ; Keep going

:return_result_done
    rd_a0 ~return_result_string_2 auipc ; Using "ret\n"
    rd_a0 rs1_a0 !return_result_string_2 addi
    rd_ra $emit_out jal               ; Emit it

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; process_break function
; Receives nothing
; Returns nothing
; Handles the break out of loops case
; Uses a1 for struct token_list* break_frame and a2 for struct token_list* I
:process_break
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_t0 ~break_target_head auipc    ; Get break_target_head
    rd_t0 rs1_t0 !break_target_head addi
    rd_a0 rs1_t0 ld                   ; Catch big error
    rs1_a0 @process_break_bad beqz    ; Exit if IF(NULL == break_target_head)

    rd_a2 rs1_s11 !8 ld               ; I = function->locals
    rd_t0 ~break_frame auipc          ; Get break_frame
    rd_t0 rs1_t0 !break_frame addi
    rd_a1 rs1_t0 ld                   ; Put break_frame in the right spot
    rd_a0 ~process_break_string_1 auipc ; Using "rd_a1 rs1_sp ld	# break_cleanup_locals..."
    rd_a0 rs1_a0 !process_break_string_1 addi

:process_break_iter
    rs1_a2 @process_break_cleaned beqz ; We are done IF (NULL == I)
    rs1_a1 rs2_a2 @process_break_cleaned beq ; We are done IF I != break_frame

    rd_ra $emit_out jal               ; Emit it
    rd_a2 rs1_a2 ld                   ; I = I->NEXT
    $process_break_iter jal           ; Keep looping

:process_break_cleaned
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    rd_a0 ~process_break_string_2 auipc ; Using "$"
    rd_a0 rs1_a0 !process_break_string_2 addi
    rd_ra $emit_out jal               ; Emit it

    rd_t0 ~break_target_head auipc    ; Using break_target_head
    rd_t0 rs1_t0 !break_target_head addi
    rd_a0 rs1_t0 ld                   ; Get what we are in
    rd_ra $emit_out jal               ; Emit it

    rd_t0 ~break_target_func auipc    ; Using break_target_func
    rd_t0 rs1_t0 !break_target_func addi
    rd_a0 rs1_t0 ld                   ; Get what function we are in
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~underline auipc            ; Using "_"
    rd_a0 rs1_a0 !underline addi
    rd_ra $emit_out jal               ; Emit it

    rd_t0 ~break_target_num auipc    ; Using break_target_num
    rd_t0 rs1_t0 !break_target_num addi
    rd_a0 rs1_t0 ld                   ; Get the digits
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~process_break_string_3 auipc ; Using " jal\n"
    rd_a0 rs1_a0 !process_break_string_3 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~process_break_string_4 auipc ; Using "ERROR in break statement\nMissing ;\n"
    rd_a0 rs1_a0 !process_break_string_4 addi
    rd_a1 ~semicolon auipc            ; Using ";"
    rd_a1 rs1_a1 !semicolon addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret

:process_break_bad
    ; Breaking badly
    rd_s3 !2 addi                     ; write to standard error
    rd_a0 rs1_a2                      ; Put S in the right place
    rd_ra $File_Print jal             ; print it

    rd_a0 ~process_break_string_0 auipc ; Ending string
    rd_a0 rs1_a0 !process_break_string_0 addi
    rd_ra $File_Print jal             ; print it
    $Fail jal                         ; Abort Hard


; expression function
; Receives Nothing
; Returns Nothing
; Walks global_token and updates output_list
; Uses a0 and a1 for match and a2 for char* store
:expression
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_ra $bitwise_expr jal           ; Collect bitwise expressions

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~equal auipc                ; "="
    rd_a0 rs1_a0 !equal addi
    rd_ra $match jal                  ; IF global_token->S == "="
    rs1_a0 @expression_done bnez      ; We have to deal with assignment

    ; Deal with possible assignment
    rd_a2 ~expression_string_1 auipc  ; Assume "rs1_a1 rs2_a0 sb\n" by default
    rd_a2 rs1_a2 !expression_string_1 addi
    rd_a1 rs1_s4 !8 ld                ; global_token->prev
    rd_a1 rs1_a1 !16 ld               ; global_token->prev->S
    rd_a0 ~close_bracket auipc        ; Using "]"
    rd_a0 rs1_a0 !close_bracket addi
    rd_ra $match jal                  ; IF global_token->S == "]"
    rs1_a0 @expression_int bnez       ; Otherwise INT

    ; Deal with char
    rd_a1 ~current_target auipc       ; Using current_target
    rd_a1 rs1_a1 !current_target addi
    rd_a1 rs1_a1 ld                   ; current_target
    rd_a1 rs1_a1 !48 ld               ; current_target->NAME
    rd_a0 ~type_char_indirect_name auipc ; Using "char *"
    rd_a0 rs1_a0 !type_char_indirect_name addi
    rd_ra $match jal                  ; Intentional inefficiency because I feel like it
    rs1_a0 @expression_int bnez       ; IF current_target->NAME == "char*"

    $expression_common jal            ; Looks like we have to use "rs1_a1 rs2_a0 sb\n"

:expression_int
    rd_a2 ~expression_string_0 auipc  ; Using "rs1_a1 rs2_a0 sd\n"
    rd_a2 rs1_a2 !expression_string_0 addi

:expression_common
    rd_a0 ~expression auipc           ; Passing expression
    rd_a0 rs1_a0 !expression addi
    rd_ra $common_recursion jal       ; Recurse
    rd_a0 rs1_a2 mv                   ; Using Store
    rd_ra $emit_out jal               ; Emit it
    rd_t0 ~current_target auipc       ; Using current_target
    rd_t0 rs1_t0 !current_target addi
    rs1_t0 sd                         ; current_target = NULL
    
:expression_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; bitwise_expr function
; Receives nothing
; Returns nothing
; Walks global_token list and updates output list
; Just calls other functions
:bitwise_expr
    rd_sp rs1_sp !-8 addi             ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra

    rd_ra $relational_expr jal        ; Walk up the tree
    rd_ra $bitwise_expr_stub jal      ; Let general recursion do the work

    rd_ra rs1_sp ld                   ; restore ra
    rd_sp rs1_sp !8 addi              ; deallocate stack
    ret


; bitwise_expr_stub function
; Receives nothing
; Returns Nothing
; Just calls general_recursion a bunch
; Uses a0, a1, a2 and a3 for passing constants to general recursion
:bitwise_expr_stub
    rd_sp rs1_sp !-32 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3

    rd_a0 ~relational_expr auipc      ; Using relational_expr
    rd_a0 rs1_a0 !relational_expr addi
    rd_a1 ~bitwise_expr_stub_string_0 auipc ; Using "rd_a0 rs1_a1 rs2_a0 and\n"
    rd_a1 rs1_a1 !bitwise_expr_stub_string_0 addi
    rd_a2 ~bitwise_and auipc          ; Using "&"
    rd_a2 rs1_a2 !bitwise_and addi
    rd_a3 ~bitwise_expr_stub auipc    ; And recurse
    rd_a3 rs1_a3 !bitwise_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~relational_expr auipc      ; Using relational_expr
    rd_a0 rs1_a0 !relational_expr addi
    rd_a1 ~bitwise_expr_stub_string_0 auipc ; Using "rd_a0 rs1_a1 rs2_a0 and\n"
    rd_a1 rs1_a1 !bitwise_expr_stub_string_0 addi
    rd_a2 ~logical_and auipc          ; Using "&&"
    rd_a2 rs1_a2 !logical_and addi
    rd_a3 ~bitwise_expr_stub auipc    ; And recurse
    rd_a3 rs1_a3 !bitwise_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~relational_expr auipc      ; Using relational_expr
    rd_a0 rs1_a0 !relational_expr addi
    rd_a1 ~bitwise_expr_stub_string_1 auipc ; Using "rd_a0 rs1_a1 rs2_a0 or\n"
    rd_a1 rs1_a1 !bitwise_expr_stub_string_1 addi
    rd_a2 ~bitwise_or auipc           ; Using "|"
    rd_a2 rs1_a2 !bitwise_or addi
    rd_a3 ~bitwise_expr_stub auipc    ; And recurse
    rd_a3 rs1_a3 !bitwise_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~relational_expr auipc      ; Using relational_expr
    rd_a0 rs1_a0 !relational_expr addi
    rd_a1 ~bitwise_expr_stub_string_1 auipc ; Using "rd_a0 rs1_a1 rs2_a0 or\n"
    rd_a1 rs1_a1 !bitwise_expr_stub_string_1 addi
    rd_a2 ~logical_or auipc           ; Using "||"
    rd_a2 rs1_a2 !logical_or addi
    rd_a3 ~bitwise_expr_stub auipc    ; And recurse
    rd_a3 rs1_a3 !bitwise_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~relational_expr auipc      ; Using relational_expr
    rd_a0 rs1_a0 !relational_expr addi
    rd_a1 ~bitwise_expr_stub_string_2 auipc ; Using "rd_a0 rs1_a1 rs2_a0 xor\n"
    rd_a1 rs1_a1 !bitwise_expr_stub_string_2 addi
    rd_a2 ~bitwise_xor auipc          ; Using "^"
    rd_a2 rs1_a2 !bitwise_xor addi
    rd_a3 ~bitwise_expr_stub auipc    ; And recurse
    rd_a3 rs1_a3 !bitwise_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_sp rs1_sp !32 addi             ; deallocate stack
    ret


; relational_expr function
; Receives nothing
; Returns nothing
; Walks global_token list and updates output list
; Just calls other functions
:relational_expr
    rd_sp rs1_sp !-8 addi             ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra

    rd_ra $additive_expr jal          ; Walk up the tree
    rd_ra $relational_expr_stub jal   ; Recurse

    rd_ra rs1_sp ld                   ; restore ra
    rd_sp rs1_sp !8 addi              ; deallocate stack
    ret


; relational_expr_stub function
; Receives nothing
; Returns Nothing
; Just calls general_recursion a bunch
; Uses a0, a1, a2 and a3 for passing constants to general recursion
:relational_expr_stub
    rd_sp rs1_sp !-32 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3

    rd_a0 ~additive_expr auipc        ; Using additive_expr
    rd_a0 rs1_a0 !additive_expr addi
    rd_a1 ~relational_expr_stub_string_0 auipc ; Using "rd_a0 rs1_a1 rs2_a0 slt\n"
    rd_a1 rs1_a1 !relational_expr_stub_string_0 addi
    rd_a2 ~less_than_string auipc     ; Using "<"
    rd_a2 rs1_a2 !less_than_string addi
    rd_a3 ~relational_expr_stub auipc ; And recurse
    rd_a3 rs1_a3 !relational_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~additive_expr auipc        ; Using additive_expr
    rd_a0 rs1_a0 !additive_expr addi
    rd_a1 ~relational_expr_stub_string_1 auipc ; Using "rd_a0 rs1_a0 rs2_a1 slt\nrd_a0 rs1_a0 !1 xori\n"
    rd_a1 rs1_a1 !relational_expr_stub_string_1 addi
    rd_a2 ~less_than_equal_string auipc ; Using "<="
    rd_a2 rs1_a2 !less_than_equal_string addi
    rd_a3 ~relational_expr_stub auipc ; And recurse
    rd_a3 rs1_a3 !relational_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~additive_expr auipc        ; Using additive_expr
    rd_a0 rs1_a0 !additive_expr addi
    rd_a1 ~relational_expr_stub_string_2 auipc ; Using "rd_a0 rs1_a1 rs2_a0 slt\nrd_a0 rs1_a0 !1 xori\n"
    rd_a1 rs1_a1 !relational_expr_stub_string_2 addi
    rd_a2 ~greater_than_equal_string auipc ; Using ">="
    rd_a2 rs1_a2 !greater_than_equal_string addi
    rd_a3 ~relational_expr_stub auipc ; And recurse
    rd_a3 rs1_a3 !relational_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~additive_expr auipc        ; Using additive_expr
    rd_a0 rs1_a0 !additive_expr addi
    rd_a1 ~relational_expr_stub_string_3 auipc ; Using "rd_a0 rs1_a0 rs2_a1 slt\n"
    rd_a1 rs1_a1 !relational_expr_stub_string_3 addi
    rd_a2 ~greater_than_string auipc  ; Using ">"
    rd_a2 rs1_a2 !greater_than_string addi
    rd_a3 ~relational_expr_stub auipc ; And recurse
    rd_a3 rs1_a3 !relational_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~additive_expr auipc        ; Using additive_expr
    rd_a0 rs1_a0 !additive_expr addi
    rd_a1 ~relational_expr_stub_string_4 auipc ; Using "rd_a0 rs1_a0 rs2_a1 sub\nrd_a0 rs1_a0 !1 sltiu\n"
    rd_a1 rs1_a1 !relational_expr_stub_string_4 addi
    rd_a2 ~equal_to_string auipc      ; Using "=="
    rd_a2 rs1_a2 !equal_to_string addi
    rd_a3 ~relational_expr_stub auipc ; And recurse
    rd_a3 rs1_a3 !relational_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~additive_expr auipc        ; Using additive_expr
    rd_a0 rs1_a0 !additive_expr addi
    rd_a1 ~relational_expr_stub_string_5 auipc ; Using "rd_a0 rs1_a0 rs2_a1 sub\nrd_a0 rs2_a0 sltu\n"
    rd_a1 rs1_a1 !relational_expr_stub_string_5 addi
    rd_a2 ~not_equal_string auipc     ; Using "!="
    rd_a2 rs1_a2 !not_equal_string addi
    rd_a3 ~relational_expr_stub auipc ; And recurse
    rd_a3 rs1_a3 !relational_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_sp rs1_sp !32 addi             ; deallocate stack
    ret


; additive_expr function
; Receives nothing
; Returns nothing
; Walks global_token list and updates output list
; Just calls other functions
:additive_expr
    rd_sp rs1_sp !-8 addi             ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra

    rd_ra $postfix_expr jal           ; Walk up the tree
    rd_ra $additive_expr_stub jal     ; Recurse

    rd_ra rs1_sp ld                   ; restore ra
    rd_sp rs1_sp !8 addi              ; deallocate stack
    ret


; additive_expr_stub function
; Receives nothing
; Returns Nothing
; Just calls general_recursion a bunch
; Uses a0, a1, a2 and a3 for passing constants to general recursion
:additive_expr_stub
    rd_sp rs1_sp !-32 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3

    rd_a0 ~postfix_expr auipc         ; Using postfix_expr
    rd_a0 rs1_a0 !postfix_expr addi
    rd_a1 ~additive_expr_stub_string_0 auipc ; Using "rd_a0 rs1_a1 rs2_a0 add\n"
    rd_a1 rs1_a1 !additive_expr_stub_string_0 addi
    rd_a2 ~plus_string auipc          ; Using "+"
    rd_a2 rs1_a2 !plus_string addi
    rd_a3 ~additive_expr_stub auipc   ; And recurse
    rd_a3 rs1_a3 !additive_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~postfix_expr auipc         ; Using postfix_expr
    rd_a0 rs1_a0 !postfix_expr addi
    rd_a1 ~additive_expr_stub_string_1 auipc ; Using "rd_a0 rs1_a1 rs2_a0 sub\n"
    rd_a1 rs1_a1 !additive_expr_stub_string_1 addi
    rd_a2 ~minus_string auipc         ; Using "-"
    rd_a2 rs1_a2 !minus_string addi
    rd_a3 ~additive_expr_stub auipc   ; And recurse
    rd_a3 rs1_a3 !additive_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~postfix_expr auipc         ; Using postfix_expr
    rd_a0 rs1_a0 !postfix_expr addi
    rd_a1 ~additive_expr_stub_string_2 auipc ; Using "rd_a0 rs1_a1 rs2_a0 mul\n"
    rd_a1 rs1_a1 !additive_expr_stub_string_2 addi
    rd_a2 ~multiply_string auipc      ; Using "*"
    rd_a2 rs1_a2 !multiply_string addi
    rd_a3 ~additive_expr_stub auipc   ; And recurse
    rd_a3 rs1_a3 !additive_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~postfix_expr auipc         ; Using postfix_expr
    rd_a0 rs1_a0 !postfix_expr addi
    rd_a1 ~additive_expr_stub_string_3 auipc ; Using "rd_a0 rs1_a1 rs2_a0 div\n"
    rd_a1 rs1_a1 !additive_expr_stub_string_3 addi
    rd_a2 ~divide_string auipc        ; Using "/"
    rd_a2 rs1_a2 !divide_string addi
    rd_a3 ~additive_expr_stub auipc   ; And recurse
    rd_a3 rs1_a3 !additive_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~postfix_expr auipc         ; Using postfix_expr
    rd_a0 rs1_a0 !postfix_expr addi
    rd_a1 ~additive_expr_stub_string_4 auipc ; Using "rd_a0 rs1_a1 rs2_a0 rem\n"
    rd_a1 rs1_a1 !additive_expr_stub_string_4 addi
    rd_a2 ~modulus_string auipc       ; Using "%"
    rd_a2 rs1_a2 !modulus_string addi
    rd_a3 ~additive_expr_stub auipc   ; And recurse
    rd_a3 rs1_a3 !additive_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~postfix_expr auipc         ; Using postfix_expr
    rd_a0 rs1_a0 !postfix_expr addi
    rd_a1 ~additive_expr_stub_string_5 auipc ; Using "rd_a0 rs1_a1 rs2_a0 sll\n"
    rd_a1 rs1_a1 !additive_expr_stub_string_5 addi
    rd_a2 ~left_shift_string auipc    ; Using "<<"
    rd_a2 rs1_a2 !left_shift_string addi
    rd_a3 ~additive_expr_stub auipc   ; And recurse
    rd_a3 rs1_a3 !additive_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_a0 ~postfix_expr auipc         ; Using postfix_expr
    rd_a0 rs1_a0 !postfix_expr addi
    rd_a1 ~additive_expr_stub_string_6 auipc ; Using "rd_a0 rs1_a1 rs2_a0 srl\n"
    rd_a1 rs1_a1 !additive_expr_stub_string_6 addi
    rd_a2 ~right_shift_string auipc   ; Using ">>"
    rd_a2 rs1_a2 !right_shift_string addi
    rd_a3 ~additive_expr_stub auipc   ; And recurse
    rd_a3 rs1_a3 !additive_expr_stub addiw
    rd_ra $general_recursion jal      ; Hit it

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_sp rs1_sp !32 addi             ; deallocate stack
    ret


; postfix_expr function
; Receives nothing
; Returns Nothing
; Walks global_token list and updates output list
; just calls other function
:postfix_expr
    rd_sp rs1_sp !-8 addi             ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra

    rd_ra $primary_expr jal           ; Walk up the tree
    rd_ra $postfix_expr_stub jal      ; Recurse

    rd_ra rs1_sp ld                   ; restore ra
    rd_sp rs1_sp !8 addi              ; deallocate stack
    ret


; postfix_expr_stub function
; Receives nothing
; Returns Nothing
; Checks for "[" and "->" and deals with them otherwise does nothing
; Uses a0, a1, a2 and a3 for passing constants to general recursion
:postfix_expr_stub
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~open_bracket auipc         ; Using "["
    rd_a0 rs1_a0 !open_bracket addi
    rd_ra $match jal                  ; IF global_token->S == "["
    rs1_a0 @postfix_expr_stub_arrow bnez ; then we have an array, else try arrow

    ; Deal with array
    rd_ra $postfix_expr_array jal     ; Get it
    rd_ra $postfix_expr_stub jal      ; Recurse

:postfix_expr_stub_arrow
    rd_a0 ~arrow_string auipc         ; Using "->"
    rd_a0 rs1_a0 !arrow_string addi
    rd_ra $match jal                  ; IF global_token->S == "->"
    rs1_a0 @postfix_expr_stub_done bnez ; then have to deal with struct offset, else done

    ; Deal with arrow
    rd_ra $postfix_expr_arrow jal     ; Get it
    rd_ra $postfix_expr_stub jal      ; Recurse

:postfix_expr_stub_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret


; unary_expr_sizeof function
; Receives nothing
; Returns nothing
; Uses a2 for A->SIZE
:unary_expr_sizeof
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 ~unary_expr_sizeof_string_0 auipc ; Using "ERROR in unary_expr\nMissing (\n"
    rd_a0 rs1_a0 !unary_expr_sizeof_string_0 addi
    rd_a1 ~open_paren auipc           ; Using "("
    rd_a1 rs1_a1 !open_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_ra $type_name jal              ; Get the type
    rd_a2 rs1_a0 !8 ld                ; Set A->TYPE

    rd_a0 ~unary_expr_sizeof_string_1 auipc ; Using "ERROR in unary_expr\nMissing )\n"
    rd_a0 rs1_a0 !unary_expr_sizeof_string_1 addi
    rd_a1 ~close_paren auipc          ; Using ")"
    rd_a1 rs1_a1 !close_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_a0 ~unary_expr_sizeof_string_2 auipc ; Using "rd_a0 !"
    rd_a0 rs1_a0 !unary_expr_sizeof_string_2 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_a2 mv                   ; Put A->SIZE in the right place
    rd_ra $numerate_number jal        ; Turn into string
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~unary_expr_sizeof_string_3 auipc ; Using " addi\n"
    rd_a0 rs1_a0 !unary_expr_sizeof_string_3 addi
    rd_ra $emit_out jal               ; Emit it

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; postfix_expr_array function
; Receives Nothing
; Returns Nothing
; Uses a1 for struct type* ARRAY and a2 for char* ASSIGN
:postfix_expr_array
    rd_sp rs1_sp !-32 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a0 ~current_target auipc       ; Using current_target
    rd_a0 rs1_a0 !current_target addi
    rd_a0 rs1_a0 ld                   ; ARRAY = current_target
    rs1_sp rs2_a0 @24 sd              ; Protect it

    rd_a0 ~expression auipc           ; Using expression
    rd_a0 rs1_a0 !expression addi
    rd_ra $common_recursion jal       ; Recurse

    rd_a1 rs1_sp !24 ld               ; Restore array
    rd_a0 ~current_target auipc       ; Using current_target
    rd_a0 rs1_a0 !current_target addi
    rs1_a0 rs2_a1 sd                  ; current_target = ARRAY
    rd_a1 rs1_a0 ld                   ; Dereferece current_target

    rd_a2 ~postfix_expr_array_string_0 auipc ; ASSIGN = "rd_a0 rs1_a0 ld\n"
    rd_a2 rs1_a2 !postfix_expr_array_string_0 addi

    rd_a0 ~type_char_indirect_name auipc ; Using "char*"
    rd_a0 rs1_a0 !type_char_indirect_name addi
    rd_a1 rs1_a1 !48 ld               ; current_target->NAME
    rd_ra $match jal                  ; IF current_target->NAME == "char*"
    rs1_a0 @postfix_expr_array_large bnez ; load a byte. otherwise adjust

    ; Deal with loading a byte
    rd_a2 ~postfix_expr_array_string_1 auipc ; ASSIGN = "rd_a0 rs1_a0 lbu\n"
    rd_a2 rs1_a2 !postfix_expr_array_string_1 addi
    $postfix_expr_array_common jal    ; Do the next bit

:postfix_expr_array_large
    rd_a0 ~postfix_expr_array_string_2 auipc ; Using "rd_a0 rs1_a0 rs2_x"
    rd_a0 rs1_a0 !postfix_expr_array_string_2 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~current_target auipc       ; Using current_target
    rd_a0 rs1_a0 !current_target addi
    rd_a0 rs1_a0 ld                   ; current_target
    rd_a0 rs1_a0 !24 ld               ; current_target->INDIRECT
    rd_a0 rs1_a0 !8 ld                ; current_target->INDIRECT->SIZE
    rd_ra $ceil_log2 jal              ; ceil_log2(current_target->indirect->size)
    rd_ra $numerate_number jal        ; numerate_number(ceil_log2(current_target->indirect->size))
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~postfix_expr_array_string_3 auipc ; Using " slli\n"
    rd_a0 rs1_a0 !postfix_expr_array_string_3 addi
    rd_ra $emit_out jal               ; Emit it

:postfix_expr_array_common
    rd_a0 ~postfix_expr_array_string_4 auipc ; Using "rd_a0 rs1_a1 rs2_a0 add\n"
    rd_a0 rs1_a0 !postfix_expr_array_string_4 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~postfix_expr_array_string_5 auipc ; Using "ERROR in postfix_expr\nMissing ]\n"
    rd_a0 rs1_a0 !postfix_expr_array_string_5 addi
    rd_a1 ~close_bracket auipc        ; Using "]"
    rd_a1 rs1_a1 !close_bracket addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~equal auipc                ; Using "="
    rd_a0 rs1_a0 !equal addi
    rd_ra $match jal                  ; IF global_token->S == "="
    rs1_a0 @postfix_expr_array_done bnez ; We need to preserve address, otherwise be done

    ; Clearing out assign
    rd_a2 ~postfix_expr_array_string_6 auipc ; ASSIGN = ""
    rd_a2 rs1_a2 !postfix_expr_array_string_6 addi

:postfix_expr_array_done
    rd_a0 rs1_a2 mv                   ; Using ASSIGN
    rd_ra $emit_out jal               ; Emit it

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !32 addi             ; deallocate stack
    ret


; ceil_log2 function
; Receives int a in a0
; Performs log2 on A and
; Returns result in a0
; Uses a1 for INT A and a2 for INT RESULT
:ceil_log2
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rs2_a0 mv                         ; RESULT = 0

    rd_a1 rs1_a0 mv                   ; put A in right place
    rd_a0 rs1_a0 !-1 addi             ; (A - 1)
    rd_a0 rs1_a0 rs2_a1 and           ; A & (A - 1)
    rs1_a0 @ceil_log2_iter bnez       ; IF 0 == (A & (A - 1)) then starting from -1

    rd_a2 !-1 addi                    ; Result = -1

:ceil_log2_iter
    rs1_a1 @ceil_log2_done beqz       ; IF A == 0 we are done

    rd_a2 rs1_a2 !1 addi              ; RESULT = RESULT + 1
    rd_a1 rs1_a1 rs2_x1 srli          ; A = A >> 1
    $ceil_log2_iter jal               ; Keep looping

:ceil_log2_done
    rd_a0 rs1_a2 mv                   ; Return RESULT
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; postfix_expr_arrow function
; Receives nothing
; Returns nothing
; Emits a bunch and updates current_target
; Uses a1 for struct type* I
:postfix_expr_arrow
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1

    rd_a0 ~postfix_expr_arrow_string_0 auipc ; Using "# looking up offset\n"
    rd_a0 rs1_a0 !postfix_expr_arrow_string_0 addi
    rd_ra $emit_out jal               ; Emit it

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~current_target auipc       ; Using current_target
    rd_a0 rs1_a0 !current_target addi
    rd_a0 rs1_a0 ld                   ; current_target
    rd_ra $lookup_member jal          ; lookup_member(current_target, global_token->s)
    rd_a1 rs1_a0 mv                   ; struct type* I = lookup_member(current_target, global_token->s)

    rd_a0 rs1_a0 !40 ld               ; I->TYPE
    rd_t0 ~current_target auipc       ; Using current_target
    rd_t0 rs1_t0 !current_target addi
    rs1_t0 rs2_a0 sd                  ; current_target = I->TYPE

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 rs1_a1 !16 ld               ; I->OFFSET
    rs1_a0 @postfix_expr_arrow_first beqz ; IF 0 != I->OFFSET then we don't need to do an offset

    ; Deal with needing an offset
    rd_a0 ~postfix_expr_arrow_string_1 auipc ; Using "# -> offset calculation\nrd_a1 !"
    rd_a0 rs1_a0 !postfix_expr_arrow_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_a1 !16 ld               ; I->OFFSET
    rd_ra $numerate_number jal        ; Convert to string
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~postfix_expr_arrow_string_2 auipc ; Using " addi\nrd_a0 rs1_a1 rs2_a0 add\n"
    rd_a0 rs1_a0 !postfix_expr_arrow_string_2 addi
    rd_ra $emit_out jal               ; Emit it

:postfix_expr_arrow_first
    rd_a0 rs1_a1 !8 ld                ; I->SIZE
    rd_t0 !4 addi                     ; 4
    rs1_a0 rs2_t0 @postfix_expr_arrow_done blt ; Check IF I->SIZE >= 4, otherwise be done

    ; Last chance for load
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~equal auipc                ; Using "="
    rd_a0 rs1_a0 !equal addi
    rd_ra $match jal                  ; IF global_token->S == "="
    rs1_a0 @postfix_expr_arrow_done beqz ; Then we have assignment and should not load

    ; Deal with load case
    rd_a0 ~postfix_expr_arrow_string_3 auipc ; Using "rd_a0 rs1_a0 ld\n"
    rd_a0 rs1_a0 !postfix_expr_arrow_string_3 addi
    rd_ra $emit_out jal               ; Emit it

:postfix_expr_arrow_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret


; primary_expr function
; Receives nothing
; Returns nothing
:primary_expr
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~sizeof_string auipc        ; Using postfix_expr
    rd_a0 rs1_a0 !sizeof_string addi
    rd_ra $match jal                  ; See if match
    rs1_a0 @primary_expr_neg bnez     ; Otherwise try negatives

    ; Deal with sizeof
    rd_ra $unary_expr_sizeof jal      ; Lets do this
    $primary_expr_done jal            ; We are done

:primary_expr_neg
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !45 addi                    ; "-"
    rs1_a0 rs2_t0 @primary_expr_not bne ; Try negative IF global_token->S[0] == "-", else not

    ; Deal with negative numbers
    rd_a0 ~primary_expr_string_0 auipc ; Using "rd_a0 mv\n"
    rd_a0 rs1_a0 !primary_expr_string_0 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~postfix_expr auipc         ; Using postfix_expr
    rd_a0 rs1_a0 !postfix_expr addi
    rd_ra $common_recursion jal       ; Get what it is notting

    rd_a0 ~primary_expr_string_1 auipc ; Using "rd_a0 rs1_a1 rs2_a0 sub\n"
    rd_a0 rs1_a0 !primary_expr_string_1 addi
    rd_ra $emit_out jal               ; Emit it
    $primary_expr_done jal            ; We are done

:primary_expr_not
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !33 addi                    ; IF global_token->S[0] == "!"
    rs1_a0 rs2_t0 @primary_expr_bin bne ; Otherwise try '~'

    ; Deal with logical not
    rd_a0 ~primary_expr_string_2 auipc ; Using "rd_a0 !1 addi\n"
    rd_a0 rs1_a0 !primary_expr_string_2 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~postfix_expr auipc         ; Using postfix_expr
    rd_a0 rs1_a0 !postfix_expr addi
    rd_ra $common_recursion jal       ; Get what it is notting

    rd_a0 ~primary_expr_string_3 auipc ; Using "rd_a0 rs1_a1 rs2_a0 xor\n"
    rd_a0 rs1_a0 !primary_expr_string_3 addi
    rd_ra $emit_out jal               ; Emit it
    $primary_expr_done jal            ; We are done

:primary_expr_bin
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !126 addi                   ; IF global_token->S[0] == "~"
    rs1_a0 rs2_t0 @primary_expr_paren bne ; Otherwise try paren

    ; Deal with binary not_equal_string
    rd_a0 ~postfix_expr auipc         ; Using postfix_expr
    rd_a0 rs1_a0 !postfix_expr addi

    rd_a0 ~postfix_expr auipc         ; Using postfix_expr
    rd_a0 rs1_a0 !postfix_expr addi
    rd_ra $common_recursion jal       ; Get what it is notting

    rd_a0 ~primary_expr_string_4 auipc ; Using "rd_a0 rs1_a0 not\n"
    rd_a0 rs1_a0 !primary_expr_string_4 addi
    rd_ra $emit_out jal               ; Emit it
    $primary_expr_done jal            ; We are done

:primary_expr_paren
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !40 addi                    ; IF global_token->S[0] == "("
    rs1_a0 rs2_t0 @primary_expr_ch bne ; Otherwise try paren

    ; deal with nesting
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next
    rd_ra $expression jal             ; Lets recurse

    rd_a0 ~primary_expr_string_5 auipc ; Using Error in Primary expression\nDidn't get )\n"
    rd_a0 rs1_a0 !primary_expr_string_5 addi
    rd_a1 ~close_paren auipc          ; Using ")"
    rd_a1 rs1_a1 !close_paren addi
    rd_ra $require_match jal          ; Make sure we have it
    $primary_expr_done jal            ; We are done

:primary_expr_ch
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !39 addi                    ; IF global_token->S[0] == "'"
    rs1_a0 rs2_t0 @primary_expr_str bne ; Otherwise try string

    ; Deal with chars
    rd_ra $primary_expr_char jal      ; Handle that char
    $primary_expr_done jal            ; We are done

:primary_expr_str
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !34 addi                    ; IF global_token->S[0] == '"'
    rs1_a0 rs2_t0 @primary_expr_var bne ; Otherwise try variable

    ; Deal with strings
    rd_ra $primary_expr_string jal    ; Handle that string
    $primary_expr_done jal            ; We are done

:primary_expr_var
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_a1 ~primary_expr_string_6 auipc ; Using "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
    rd_a1 rs1_a1 !primary_expr_string_6 addi
    rd_ra $In_Set jal                 ; See if we have a match
    rs1_a0 @primary_expr_num beqz     ; otherwise try number

    ; Deal with variables
    rd_ra $primary_expr_variable jal  ; Deal with variable
    $primary_expr_done jal            ; We are done

:primary_expr_num
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_a1 ~primary_expr_string_7 auipc ; Using "0123456789"
    rd_a1 rs1_a1 !primary_expr_string_7 addi
    rd_ra $In_Set jal                 ; See if we have a match
    rs1_a0 @primary_expr_fail beqz    ; Otherwise we failed

    ; Deal with numbers
    rd_ra $primary_expr_number jal    ; Collect the number
    $primary_expr_done jal            ; Be done

:primary_expr_fail
    ; looks like we hit bad input
    ; abort before it gets bad
    rd_ra $primary_expr_failure jal   ; No match means failure

:primary_expr_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret


; primary_expr_variable function
; Receives nothing
; Returns nothing
; Walks global and updates output
; Uses a0 for struct token_list* a and a2 for char* S
:primary_expr_variable
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a2 rs1_s4 !16 ld               ; global_token->S
    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 rs1_a2 mv                   ; Using S
    rd_a1 rs1_s5 mv                   ; Using global_constant_list
    rd_ra $sym_lookup jal             ; sym_lookup(s, global_constant_list)
    rs1_a0 @primary_expr_variable_local beqz ; Try locals next

    ; Deal with constant load
    rd_a1 rs1_a0 !32 ld               ; a->ARGS
    rd_a0 ~primary_expr_variable_string_1 auipc ; Using "rd_a0 ~"
    rd_a0 rs1_a0 !primary_expr_variable_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_a1 !16 ld               ; a->ARGS->S
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~primary_expr_variable_string_2 auipc ; Using " lui\nrd_a0 rs1_a0 !"
    rd_a0 rs1_a0 !primary_expr_variable_string_2 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_a1 !16 ld               ; a->ARGS->S
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~primary_expr_variable_string_3 auipc ; Using " addiw\n"
    rd_a0 rs1_a0 !primary_expr_variable_string_3 addi
    rd_ra $emit_out jal               ; Emit it
    $primary_expr_variable_done jal   ; Be done

:primary_expr_variable_local
    rd_a0 rs1_a2 mv                   ; Using S
    rd_a1 rs1_s11 !8 ld               ; function->locals
    rd_ra $sym_lookup jal             ; sym_lookup(s, function->locals)
    rs1_a0 @primary_expr_variable_arguments beqz ; IF NULL == sym_lookup(s, function->locals)

    ; Deal with local load
    rd_ra $variable_load jal          ; Collect it
    $primary_expr_variable_done jal   ; Be done

:primary_expr_variable_arguments
    rd_a0 rs1_a2 mv                   ; Using S
    rd_a1 rs1_s11 !32 ld              ; function->args
    rd_ra $sym_lookup jal             ; sym_lookup(s, function->args)
    rs1_a0 @primary_expr_variable_function beqz ; IF NULL == sym_lookup(s, function->args)

    ; Deal with argument load
    rd_ra $variable_load jal          ; Collect it
    $primary_expr_variable_done jal   ; Be done

:primary_expr_variable_function
    rd_a0 rs1_a2 mv                   ; Using S
    rd_a1 rs1_s8 mv                   ; global_function_list
    rd_ra $sym_lookup jal             ; sym_lookup(s, global_function_list)
    rs1_a0 @primary_expr_variable_global beqz ; IF NULL == sym_lookup(s, global_function_list)

    ; Deal with functions
    rd_ra $function_load jal          ; Deal with the function
    $primary_expr_variable_done jal   ; Be done

:primary_expr_variable_global
    rd_a0 rs1_a2 mv                   ; Using S
    rd_a1 rs1_s6 mv                   ; Using global_symbol_list
    rd_ra $sym_lookup jal             ; sym_lookup(s, global_symbol_list)
    rs1_a0 @primary_expr_variable_error beqz ; Give up IF NULL == sym_lookup(s, global_symbol_list)

    ; Deal with globals
    rd_ra $global_load jal            ; Collect that global
    $primary_expr_variable_done jal   ; Be done

:primary_expr_variable_error
    rd_s3 !2 addi                     ; write to standard error

    rd_a0 rs1_a2 mv                   ; Put S in the right place
    rd_ra $File_Print jal             ; print it

    rd_a0 ~primary_expr_variable_string_0 auipc ; Ending string
    rd_a0 rs1_a0 !primary_expr_variable_string_0 addi
    rd_ra $File_Print jal             ; print it
    $Fail jal                         ; Abort Hard

:primary_expr_variable_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; function_call function
; Receives char* S in a0 and int BOOL in a1
; Builds stack frames before and tears them down after function calls
; Uses a2 for char* S, a3 for int BOOL, a4 for PASSED
:function_call
    rd_sp rs1_sp !-40 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3
    rs1_sp rs2_a4 @32 sd              ; protect a4

    rd_a2 rs1_a0 mv                   ; Put S in place
    rd_a3 rs1_a1 mv                   ; Put BOOL in place
    rd_a4 mv                          ; PASSED = 0

    rd_a0 ~function_call_string_0 auipc ; Using "ERROR in process_expression_list\nNo ( was found\n"
    rd_a0 rs1_a0 !function_call_string_0 addi
    rd_a1 ~open_paren auipc           ; Using "("
    rd_a1 rs1_a1 !open_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rd_a0 ~function_call_string_1 auipc ; Using "rd_sp rs1_sp !-24 addi\nrs1_sp rs2_ra @8 sd\t# Protect the old return pointer\n"
    rd_a0 rs1_a0 !function_call_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_call_string_2 auipc ; Using "rs1_sp rs2_fp sd\t# Protect the old frame pointer\n"
    rd_a0 rs1_a0 !function_call_string_2 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_call_string_2a auipc ; Using "rs1_sp rs2_tp @16 sd\t# Protect temp register we are going to use\n"
    rd_a0 rs1_a0 !function_call_string_2a addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_call_string_2b auipc ; Using "rd_tp rs1_sp mv\t# The base pointer to-be\n"
    rd_a0 rs1_a0 !function_call_string_2b addi
    rd_ra $emit_out jal               ; Emit it

    ;rd_a0 ~function_call_string_3 auipc ; Using "rd_fp rs1_sp mv\t# Copy new base pointer\n"
    ;rd_a0 rs1_a0 !function_call_string_3 addi
    ;rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !41 addi                    ; ")"
    rs1_a0 rs2_t0 @function_call_gen_done beq ; IF global_token->S[0] == ")" then no arguments to send

    ; looks like we have arguments to collect
    rd_ra $expression jal             ; Collect the argument
    rd_a0 ~function_call_string_4 auipc ; Using "rd_sp rs1_sp !-8 addi\nrs1_sp rs2_a0 sd\t#_process_expression1\n"
    rd_a0 rs1_a0 !function_call_string_4 addi
    rd_ra $emit_out jal               ; Emit it
    rd_a4 !1 addi                     ; PASSED = 1

:function_call_gen_iter
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 lbu                  ; global_token->S[0]
    rd_t0 !44 addi                    ; ","
    rs1_a0 rs2_t0 @function_call_gen_done bne ; Check IF global_token->S[0] == ","

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_ra $expression jal             ; Collect the argument

    rd_a0 ~function_call_string_5 auipc ; Using "rd_sp rs1_sp !-8 addi\nrs1_sp rs2_a0 sd\t#_process_expression2\n"
    rd_a0 rs1_a0 !function_call_string_5 addi
    rd_ra $emit_out jal               ; Emit it
    rd_a4 rs1_a4 !1 addi              ; PASSED = PASSED + 1
    $function_call_gen_iter jal       ; Keep trying

:function_call_gen_done
    ; All is collected
    rd_a0 ~function_call_string_6 auipc ; Using "ERROR in process_expression_list\nNo ) was found\n"
    rd_a0 rs1_a0 !function_call_string_6 addi
    rd_a1 ~close_paren auipc          ; Using ")"
    rd_a1 rs1_a1 !close_paren addi
    rd_ra $require_match jal          ; Make sure we have it

    rs1_a3 @function_call_static bnez ; IF (BOOL == TRUE) then deal with function pointer, else static call

    ; Deal with a passed function pointer
    rd_a0 ~function_call_string_7 auipc ; Using "rd_a0 rs1_fp !-"
    rd_a0 rs1_a0 !function_call_string_7 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_a2 mv                   ; Using S
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_call_string_8 auipc ; Using " addi\nrd_a0 rs1_a0 ld\n"
    rd_a0 rs1_a0 !function_call_string_8 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_call_string_9 auipc ; Using "rd_fp rs1_tp mv\n"
    rd_a0 rs1_a0 !function_call_string_9 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_call_string_10 auipc ; Using "rd_ra rs1_a0 jalr\n"
    rd_a0 rs1_a0 !function_call_string_10 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_call_string_13 auipc ; Using "rd_a1 rs1_sp ld\t# _process_expression_locals\nrd_sp rs1_sp !8 addi\n"
    rd_a0 rs1_a0 !function_call_string_13 addi
    $function_call_cleanup jal        ; Clean up

:function_call_static
    ; Deal with fixed function name

    rd_a0 ~function_call_string_10a auipc ; Using "rd_fp rs1_tp mv\n"
    rd_a0 rs1_a0 !function_call_string_10a addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_call_string_11 auipc ; Using "rd_ra $FUNCTION_"
    rd_a0 rs1_a0 !function_call_string_11 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_a2 mv                   ; Using S
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_call_string_12 auipc ; Using " jal\n"
    rd_a0 rs1_a0 !function_call_string_12 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_call_string_13 auipc ; Using "rd_a1 rs1_sp ld\t# _process_expression_locals\nrd_sp rs1_sp !8 addi\n"
    rd_a0 rs1_a0 !function_call_string_13 addi

:function_call_cleanup
    rs1_a4 @function_call_done beqz   ; IF PASSED == 0 then we are done

    ; The desired string is already in a0
    rd_ra $emit_out jal               ; Emit it

    rd_a4 rs1_a4 !-1 addi             ; PASSED = PASSED - 1
    $function_call_cleanup jal        ; Keep going

:function_call_done
    rd_a0 ~function_call_string_14 auipc ; Using "rd_fp rs1_sp ld\t# Restore old frame pointer\n"
    rd_a0 rs1_a0 !function_call_string_14 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_call_string_14a auipc ; Using "rd_tp rs1_sp !16 ld\t# Restore temp register\n"
    rd_a0 rs1_a0 !function_call_string_14a addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_call_string_15 auipc ; Using "rd_ra rs1_sp !8 ld\t# Restore return address\nrd_sp rs1_sp !24 addi\n"
    rd_a0 rs1_a0 !function_call_string_15 addi
    rd_ra $emit_out jal               ; Emit it

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_a4 rs1_sp !32 ld               ; restore a4
    rd_sp rs1_sp !40 addi             ; deallocate stack
    ret


; variable_load function
; Receives struct token_list* A in a0
; Returns nothing
; Updates output and current_target
; Uses a2 for A
:variable_load
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a2 rs1_a0 mv                   ; Protect A

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~open_paren auipc           ; "("
    rd_a0 rs1_a0 !open_paren addi
    rd_ra $match jal                  ; Might be a function IF global_token->S == "("
    rs1_a0 @variable_load_regular bnez ; Otherwise it is regular

    rd_a1 rs1_a2 !24 ld               ; A->TYPE
    rd_a1 rs1_a1 !48 ld               ; A->TYPE->NAME
    rd_a0 ~type_function_name auipc   ; Using "FUNCTION"
    rd_a0 rs1_a0 !type_function_name addi
    rd_ra $match jal                  ; IF A->TYPE->NAME == "FUNCTION"
    rs1_a0 @variable_load_regular bnez ; then it mus be a function, otherwise another regular

    ; deal with function
    rd_a0 rs1_a2 !32 ld               ; A->DEPTH
    rd_ra $numerate_number jal        ; Convert to string
    rd_a1 mv                          ; pass 0 for true
    rd_ra $function_call jal          ; Create the function call
    $variable_load_done jal           ; Be done

:variable_load_regular
    rd_a0 rs1_a2 !24 ld               ; A->TYPE
    rd_t0 ~current_target auipc       ; Using current_target
    rd_t0 rs1_t0 !current_target addi
    rs1_t0 rs2_a0 sd                  ; current_target = A->TYPE

    rd_a0 ~variable_load_string_0 auipc ; Using "rd_a0 rs1_fp !-"
    rd_a0 rs1_a0 !variable_load_string_0 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_a2 mv
    rd_a0 rs1_a2 !32 ld               ; A->DEPTH
    rd_ra $numerate_number jal        ; Convert to string
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~variable_load_string_1 auipc ; Using " addi\n"
    rd_a0 rs1_a0 !variable_load_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    ; Check for special case of assignment
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~equal auipc                ; Using "="
    rd_a0 rs1_a0 !equal addi
    rd_ra $match jal                  ; IF global_token->S == "="
    rs1_a0 @variable_load_done beqz   ; Then we skip loading

    ; Deal with common case
    rd_a0 ~variable_load_string_2 auipc ; Using "rd_a0 rs1_a0 ld\n"
    rd_a0 rs1_a0 !variable_load_string_2 addi
    rd_ra $emit_out jal               ; Emit it

:variable_load_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; function_load function
; Receives struct token_list* a in a0
; Returns nothing
; Uses a2 to hold A->S
:function_load
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a0 rs1_a0 !16 ld               ; A->S
    rd_a2 rs1_a0 mv                   ; Protect A->S
    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~open_paren auipc           ; Using "("
    rd_a0 rs1_a0 !open_paren addi
    rd_ra $match jal                  ; IF global_token->S == "("
    rs1_a0 @function_load_regular bnez ; then do function call, otherwise load it's address

    ; Deal with function call
    rd_a0 rs1_a2 mv                   ; Using A->S
    rd_a1 !1 addi                     ; Using FALSE
    rd_ra $function_call jal          ; Deal with it
    $function_load_done jal           ; Be done

:function_load_regular
    rd_a0 ~function_load_string_0 auipc ; Using "rd_a0 ~FUNCTION_"
    rd_a0 rs1_a0 !function_load_string_0 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_a2 mv                   ; Using A->S
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_load_string_1 auipc ; Using " auipc\nrd_a0 rs1_a0 !FUNCTION_"
    rd_a0 rs1_a0 !function_load_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_a2 mv                   ; Using A->S
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~function_load_string_2 auipc ; Using " addiw\n"
    rd_a0 rs1_a0 !function_load_string_2 addi
    rd_ra $emit_out jal               ; Emit it

:function_load_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; global_load function
; Receives struct token_list* A in a0
; Returns nothing
; Uses a1 to hold A->S
:global_load
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1

    rd_a1 rs1_a0 mv                   ; Set as A
    rd_a1 rs1_a1 !16 ld               ; Set as A->S

    rd_a0 rs1_a0 !24 ld               ; A->TYPE
    rd_t0 ~current_target auipc       ; Using current_target
    rd_t0 rs1_t0 !current_target addi
    rs1_t0 rs2_a0 sd                  ; current_target = A->TYPE

    rd_a0 ~global_load_string_0 auipc ; Using "rd_a0 ~GLOBAL_"
    rd_a0 rs1_a0 !global_load_string_0 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_a1 mv                   ; Using A->S
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~global_load_string_1 auipc ; Using " auipc\nrd_a0 rs1_a0 !GLOBAL_"
    rd_a0 rs1_a0 !global_load_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_a1 mv                   ; Using A->S
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~global_load_string_2 auipc ; Using " addi\n"
    rd_a0 rs1_a0 !global_load_string_2 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_a0 ~equal auipc ; "="
    rd_a0 rs1_a0 !equal addi
    rd_ra $match jal                  ; IF global_token->S == "="
    rs1_a0 @global_load_done beqz     ; we need to skip for assignment and be done

    ; Otherwise we are loading contents
    rd_a0 ~global_load_string_3 auipc ; Using "rd_a0 rs1_a0 ld\n"
    rd_a0 rs1_a0 !global_load_string_3 addi
    rd_ra $emit_out jal               ; Emit it

:global_load_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret


; sym_lookup function
; Receives char* S in a0 and struct token_list* symbol_list in a1
; Uses I->S in a0, S in a1 and I in a2
; Returns match or NULL
:sym_lookup
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a2 rs1_a1 mv                   ; I = symbol_list
    rd_a1 rs1_a0 mv                   ; Put S in the right place

:sym_lookup_iter
    rs1_a2 @sym_lookup_done beqz      ; We failed to find match IF NULL == I

    rd_a0 rs1_a2 !16 ld               ; Using I->S
    rd_ra $match jal                  ; IF I->S == S
    rs1_a0 @sym_lookup_done beqz      ; Then we are done, else failed

    rd_a2 rs1_a2 ld                   ; I = I->NEXT
    $sym_lookup_iter jal              ; otherwise keep looping

:sym_lookup_done
    rd_a0 rs1_a2 mv                   ; Return I
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; primary_expr_number function
; Receives nothing
; Returns nothing
; Simply uses current global token to update output and then steps to next global_token
:primary_expr_number
    rd_sp rs1_sp !-8 addi             ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra

    rd_a0 ~primary_expr_number_string_0 auipc ; Using "rd_a0 ~"
    rd_a0 rs1_a0 !primary_expr_number_string_0 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~primary_expr_number_string_1 auipc ; Using " lui\nrd_a0 rs1_a0 !"
    rd_a0 rs1_a0 !primary_expr_number_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~primary_expr_number_string_2 auipc ; Using " addiw\n"
    rd_a0 rs1_a0 !primary_expr_number_string_2 addi
    rd_ra $emit_out jal               ; Emit it

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_ra rs1_sp ld                   ; restore ra
    rd_sp rs1_sp !8 addi              ; deallocate stack
    ret


; primary_expr_char function
; Receives nothing
; Returns nothing
; Updates output_list using global_token
:primary_expr_char
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a0 ~primary_expr_char_string_0 auipc ; Using "rd_a0 !"
    rd_a0 rs1_a0 !primary_expr_char_string_0 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_a0 rs1_a0 !1 addi              ; global_token->S + 1
    rd_ra $escape_lookup jal          ; Get the char
    rd_ra $numerate_number jal        ; Convert to string
    rd_ra $emit_out jal               ; Emit it

    rd_a0 ~primary_expr_char_string_1 auipc ; Using " addi\n"
    rd_a0 rs1_a0 !primary_expr_char_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; primary_expr_string function
; receives nothing
; Returns nothing
; creates entries for string and calls to generate string output
; uses a2 for char* number_string
:primary_expr_string
    rd_sp rs1_sp !-24 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2

    rd_a0 rs1_s10 mv                  ; Get current_count
    rd_s10 rs1_s10 !1 addi            ; current_count = current_count + 1
    rd_ra $numerate_number jal        ; convert to string
    rd_a2 rs1_a0 mv                   ; put NUMBER_STRING in place

    rd_a0 ~primary_expr_string_string_0 auipc ; Using "rd_a0 ~STRING_"
    rd_a0 rs1_a0 !primary_expr_string_string_0 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~primary_expr_string_string_1 auipc ; Using "auipc\nrd_a0 rs1_a0 !STRING_"
    rd_a0 rs1_a0 !primary_expr_string_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_a1 rs1_a2 mv                   ; Passing NUMBER_STRING
    rd_ra $uniqueID_out jal           ; uniqueID_out(function->s, number_string)

    rd_a0 ~primary_expr_string_string_2 auipc ; Using "addi\n"
    rd_a0 rs1_a0 !primary_expr_string_string_2 addi
    rd_ra $emit_out jal               ; Emit it

    ; Generate the target
    rd_a0 ~primary_expr_string_string_3 auipc ; Using ":STRING_"
    rd_a0 rs1_a0 !primary_expr_string_string_3 addi
    rd_a1 ~strings_list auipc         ; Using strings_list
    rd_a1 rs1_a1 !strings_list addi
    rd_a1 rs1_a1 ld
    rd_ra $emit jal                   ; Emit it
    rd_a1 rs1_a0 mv                   ; Put new strings_list in place

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_ra $uniqueID jal               ; uniqueID(function->s, number_string)
    rd_a1 rs1_a0 mv                   ; Put new strings_list in place

    ; Parse the string
    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_ra $parse_string jal           ; convert it to useful form
    rd_ra $emit jal                   ; Emit it
    rd_t0 ~strings_list auipc         ; Using strings_list
    rd_t0 rs1_t0 !strings_list addi
    rs1_t0 rs2_a0 sd                  ; Update strings_list

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_sp rs1_sp !24 addi             ; deallocate stack
    ret


; primary_expr_failure function
; Receives nothing
; Does not return but aborts hard
; Complains about the bad input
:primary_expr_failure
    rd_s3 !2 addi                     ; write to standard error
    rd_a0 ~primary_expr_failure_string_0 auipc ; Using "Received "
    rd_a0 rs1_a0 !primary_expr_failure_string_0 addi
    rd_ra $File_Print jal             ; Print it

    rd_a0 rs1_s4 !16 ld               ; global_token->S
    rd_ra $File_Print jal             ; Print it

    rd_a0 ~primary_expr_failure_string_1 auipc ; Using "Received "
    rd_a0 rs1_a0 !primary_expr_failure_string_1 addi
    rd_ra $File_Print jal             ; Print it
    $Fail jal                         ; Abort Hard


; promote_type function
; Receives struct type* a in a0 and struct type* b in a1
; Returns the most recent type in a0
; Uses a0 for struct type* I, a2 for struct type* A and a3 for struct type* B
:promote_type
    rd_sp rs1_sp !-32 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3

    rs1_a1 @promote_type_done beqz    ; IF NULL == B, return A

    rd_a2 rs1_a0 mv                   ; Put A in place
    rd_a3 rs1_a1 mv                   ; Put B in place
    rd_a0 rs1_a1 mv                   ; If NULL == A
    rs1_a2 @promote_type_done beqz    ; IF NULL == A, return B

    ; Looks like we need to walk the list
    rd_a2 rs1_a2 !48 ld               ; A->NAME
    rd_a3 rs1_a3 !48 ld               ; B->NAME

    rd_a0 ~global_types auipc         ; Using global_types
    rd_a0 rs1_a0 !global_types addi
    rd_a0 rs1_a0 ld                   ; I = global_types

:promote_type_iter
    rs1_a0 @promote_type_done beqz    ; Be done IF NULL == I

    rd_a1 rs1_a0 !48 ld               ; I->NAME
    rs1_a1 rs2_a2 @promote_type_done beq ; Be done IF(A->NAME == I->NAME)

    rs1_a1 rs2_a3 @promote_type_done beq ; Be done IF(B->NAME == I->NAME)

    rd_a1 rs1_a0 !24 ld               ; I->INDIRECT
    rd_a1 rs1_a1 !48 ld               ; I->INDIRECT->NAME

    rs1_a1 rs2_a2 @promote_type_done beq ; Done IF(A->NAME == I->INDIRECT->NAME)

    rs1_a1 rs2_a3 @promote_type_done beq ; Done IF(B->NAME == I->INDIRECT->NAME)

    rd_a0 rs1_a0 ld                   ; I = I->NEXT
    $promote_type_iter jal            ; Keep going

:promote_type_done

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_sp rs1_sp !32 addi             ; deallocate stack
    ret


; common_recursion function
; Receives FUNCTION F in a0
; Returns Nothing
; Walks global_token list and update output_list
; Updates current_target
; Uses a1 to hold FUNCTION F and struct type* last_type
:common_recursion
    rd_sp rs1_sp !-16 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1

    rd_a1 rs1_a0 mv                   ; Put FUNCTION F safely out of the way
    rd_a0 ~common_recursion_string_0 auipc ; Using "rd_sp rs1_sp !-8 addi\t# _common_recursion\nrs1_sp rs2_a0 sd\n"
    rd_a0 rs1_a0 !common_recursion_string_0 addi
    rd_ra $emit_out jal               ; Emit it

    rd_s4 rs1_s4 ld                   ; global_token = global_token->next

    rd_a0 rs1_a1 mv                   ; Prepare for function call
    rd_t0 ~current_target auipc       ; Using current_target
    rd_t0 rs1_t0 !current_target addi
    rd_a1 rs1_t0 ld                   ; Get last_type
    rd_ra rs1_a0 jalr                 ; F()
    rd_t0 ~current_target auipc       ; Using current_target
    rd_t0 rs1_t0 !current_target addi
    rd_a0 rs1_t0 ld                   ; Get last current_target
    rd_ra $promote_type jal           ; get the right type
    rs1_t0 rs2_a0 sd                  ; Set new current target

    rd_a0 ~common_recursion_string_1 auipc ; Using "rd_a1 rs1_sp ld..."
    rd_a0 rs1_a0 !common_recursion_string_1 addi
    rd_ra $emit_out jal               ; Emit it

    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_sp rs1_sp !16 addi             ; deallocate stack
    ret


; general_recursion function
; Receives FUNCTION F in a0, char* S in a1, char* name in a2 and FUNCTION iterate in a3
; Returns nothing
; Uses a2 for char* S, a3 for FUNCTION iterate and a4 for FUNCTION F
:general_recursion
    rd_sp rs1_sp !-40 addi            ; allocate stack
    rs1_sp rs2_ra sd                  ; protect ra
    rs1_sp rs2_a1 @8 sd               ; protect a1
    rs1_sp rs2_a2 @16 sd              ; protect a2
    rs1_sp rs2_a3 @24 sd              ; protect a3
    rs1_sp rs2_a4 @32 sd              ; protect a4

    rd_a4 rs1_a0 mv                   ; Protect F
    rd_a0 rs1_a2 mv                   ; Put name in the right place
    rd_a2 rs1_a1 mv                   ; Protect S

    rd_a1 rs1_s4 !16 ld               ; global_token->S
    rd_ra $match jal                  ; IF match(name, global_token->s)
    rs1_a0 @general_recursion_done bnez ; do recursion, else skip it

    ; Deal with the recursion
    rd_a0 rs1_a4 mv                   ; Put F in the right place
    rd_ra $common_recursion jal       ; Recurse

    rd_a0 rs1_a2 mv                   ; Put S in the right place
    rd_ra $emit_out jal               ; Emit it

    rd_a0 rs1_a3 mv                   ; Put iterate in the right place
    rd_ra rs1_a0 jalr                 ; Down the rabbit hole

:general_recursion_done
    rd_ra rs1_sp ld                   ; restore ra
    rd_a1 rs1_sp !8 ld                ; restore a1
    rd_a2 rs1_sp !16 ld               ; restore a2
    rd_a3 rs1_sp !24 ld               ; restore a3
    rd_a4 rs1_sp !32 ld               ; restore a4
    rd_sp rs1_sp !40 addi             ; deallocate stack
    ret


; save_break_frame microfunction
; Overwrites a0 and a1
; Saves break frame on stack
; Returns to caller
:save_break_frame
    rd_a1 rs1_sp ld                   ; Save return Address

    rd_t0 ~break_frame auipc          ; Get break_frame
    rd_t0 rs1_t0 !break_frame addi
    rd_a0 rs1_t0 ld
    rs1_sp rs2_a0 sd                  ; Store as nested_locals

    rd_t0 ~break_target_head auipc    ; Get break_target_head
    rd_t0 rs1_t0 !break_target_head addi
    rd_a0 rs1_t0 ld
    rd_sp rs1_sp !-8 addi             ; allocate stack
    rs1_sp rs2_a0 sd                  ; Store as nested_break_head

    rd_t0 ~break_target_func auipc    ; Get break_target_func
    rd_t0 rs1_t0 !break_target_func addi
    rd_a0 rs1_t0 ld
    rd_sp rs1_sp !-8 addi             ; allocate stack
    rs1_sp rs2_a0 sd                  ; Store as nested_break_func


    rd_t0 ~break_target_num auipc    ; Get break_target_num
    rd_t0 rs1_t0 !break_target_num addi
    rd_a0 rs1_t0 ld
    rd_sp rs1_sp !-8 addi             ; allocate stack
    rs1_sp rs2_a0 sd                  ; Store as break_target_num

    rd_sp rs1_sp !-8 addi             ; allocate stack
    rs1_sp rs2_a1 sd                  ; Put return back in place
    ret


; restore_break_frame microfunction
; Overwrites a0 and a1
; Restores break frame from stack
; Returns to caller
:restore_break_frame
    rd_a1 rs1_sp ld                   ; Save return Address
    rd_sp rs1_sp !8 addi              ; deallocate stack

    rd_a0 rs1_sp ld                   ; Get nested_break_num
    rd_sp rs1_sp !8 addi              ; deallocate stack
    rd_t0 ~break_target_num auipc
    rd_t0 rs1_t0 !break_target_num addi
    rs1_t0 rs2_a0 sd                  ; Restore as nested_break_num

    rd_a0 rs1_sp ld                   ; Get break_target_func
    rd_sp rs1_sp !8 addi              ; deallocate stack
    rd_t0 ~break_target_func auipc
    rd_t0 rs1_t0 !break_target_func addi
    rs1_t0 rs2_a0 sd                  ; Restore as break_target_func

    rd_a0 rs1_sp ld                   ; Get break_target_head
    rd_sp rs1_sp !8 addi              ; deallocate stack
    rd_t0 ~break_target_head auipc
    rd_t0 rs1_t0 !break_target_head addi
    rs1_t0 rs2_a0 sd                  ; Restore as break_target_head

    rd_a0 rs1_sp ld                   ; Get break_frame
    rd_t0 ~break_frame auipc
    rd_t0 rs1_t0 !break_frame addi
    rs1_t0 rs2_a0 sd                  ; Restore as break_frame

    rs1_sp rs2_a1 sd                  ; Put return back in place
    ret


; set_break_frame microfunction
; Receives char* head in a0 and char* num in a1
; Overwrites a0 and a1
; Returns to calling function
:set_break_frame
    rd_t0 ~break_target_head auipc    ; Using break_target_head
    rd_t0 rs1_t0 !break_target_head addi
    rs1_t0 rs2_a0 sd                  ; update break_target_head

    rd_t0 ~break_target_num auipc     ; Using break_target_num
    rd_t0 rs1_t0 !break_target_num addi
    rs1_t0 rs2_a1 sd                  ; update break_target_num

    rd_a0 rs1_s11 !8 ld               ; function->locals
    rd_t0 ~break_frame auipc          ; Using break_frame
    rd_t0 rs1_t0 !break_frame addi
    rs1_t0 rs2_a0 sd                  ; break_frame = function->locals

    rd_a0 rs1_s11 !16 ld              ; function->S
    rd_t0 ~break_target_func auipc    ; Using break_target_func
    rd_t0 rs1_t0 !break_target_func addi
    rs1_t0 rs2_a0 sd                  ; break_target_func = function->S

    ret


; debug_list function
; Receives struct token_list* in RAX
; Prints contents of list and exits
; Uses s11 as list pointer
; Does NOT return
:debug_list
    rd_s11 rs1_a0 mv                  ; Protect the list pointer
    rd_s3 !2 addi                     ; write to standard error

:debug_list_iter
    ; Header
    rd_a0 ~debug_list_string0 auipc   ; Using our first string
    rd_a0 rs1_a0 !debug_list_string0 addi
    rd_ra $File_Print jal             ; Print it
    rd_a0 rs1_s11 mv                  ; Use address of pointer
    rd_ra $numerate_number jal        ; Convert it into string
    rd_ra $File_Print jal             ; Print it

    ;; NEXT
    rd_a0 ~debug_list_string1 auipc   ; Using our second string
    rd_a0 rs1_a0 !debug_list_string1 addi
    rd_ra $File_Print jal             ; Print it
    rd_a0 rs1_s11 ld                  ; Use address of pointer
    rd_ra $numerate_number jal        ; Convert it into string
    rd_ra $File_Print jal             ; Print it

    ;; PREV
    rd_a0 ~debug_list_string2 auipc   ; Using our third string
    rd_a0 rs1_a0 !debug_list_string2 addi
    rd_ra $File_Print jal             ; Print it
    rd_a0 rs1_s11 !8 ld               ; Use address of pointer
    rd_ra $numerate_number jal        ; Convert it into string
    rd_ra $File_Print jal             ; Print it

    ;; S
    rd_a0 ~debug_list_string3 auipc   ; Using our fourth string
    rd_a0 rs1_a0 !debug_list_string3 addi
    rd_ra $File_Print jal             ; Print it
    rd_a0 rs1_s11 !16 ld              ; Use address of pointer
    rd_ra $numerate_number jal        ; Convert it into string
    rd_ra $File_Print jal             ; Print it

    ;; S Contents
    rd_a0 ~debug_list_string4 auipc   ; Using our fifth string
    rd_a0 rs1_a0 !debug_list_string4 addi
    rd_ra $File_Print jal             ; Print it
    rd_a0 rs1_s11 !16 ld              ; Use address of pointer
    rs1_a0 @debug_list_null bnez      ; Display if not NULL Pointer
    rd_a0 ~debug_list_string_null auipc ; Give meaningful message instead
    rd_a0 rs1_a0 !debug_list_string_null addi
:debug_list_null
    rd_ra $File_Print jal             ; Print it

    ;; TYPE
    rd_a0 ~debug_list_string5 auipc   ; Using our sixth string
    rd_a0 rs1_a0 !debug_list_string5 addi
    rd_ra $File_Print jal             ; Print it
    rd_a0 rs1_s11 !24 ld              ; Use address of pointer
    rd_ra $numerate_number jal        ; Convert it into string
    rd_ra $File_Print jal             ; Print it

    ;; ARGS/DEPTH
    rd_a0 ~debug_list_string6 auipc   ; Using our seventh string
    rd_a0 rs1_a0 !debug_list_string6 addi
    rd_ra $File_Print jal             ; Print it
    rd_a0 rs1_s11 !32 ld              ; Use address of pointer
    rd_ra $numerate_number jal        ; Convert it into string
    rd_ra $File_Print jal             ; Print it

    rd_a0 !10 addi                    ; Add "\n"
    rd_ra $fputc jal                  ; print it
    rd_ra $fputc jal                  ; print it

    rd_s11 rs1_s11 ld                 ; TOKEN = TOKEN->NEXT
    rs1_s11 @debug_list_iter bnez     ; iterate otherwise

    $Fail jal

:ELF_data

:prim_types
:type_void
    &type_int %0                        ; NEXT
    %8 %0                               ; SIZE
    NULL                                ; OFFSET
    &type_void %0                       ; INDIRECT
    NULL                                ; MEMBERS
    &type_void %0                       ; TYPE
    &type_void_name %0                  ; NAME

:type_int
    &type_char %0                       ; NEXT
    %8 %0                               ; SIZE
    NULL                                ; OFFSET
    &type_int %0                        ; INDIRECT
    NULL                                ; MEMBERS
    &type_int %0                        ; TYPE
    &type_int_name %0                   ; NAME

:type_char
    &type_file %0                       ; NEXT
    %1 %0                               ; SIZE
    NULL                                ; OFFSET
    &type_char_indirect %0              ; INDIRECT
    NULL                                ; MEMBERS
    &type_char %0                       ; TYPE
    &type_char_name %0                  ; NAME

:type_char_indirect
    &type_file %0                       ; NEXT
    %8 %0                               ; SIZE
    NULL                                ; OFFSET
    &type_char_double_indirect %0       ; INDIRECT
    NULL                                ; MEMBERS
    &type_char_indirect %0              ; TYPE
    &type_char_indirect_name %0         ; NAME

:type_char_double_indirect
    &type_file %0                       ; NEXT
    %8 %0                               ; SIZE
    NULL                                ; OFFSET
    &type_char_double_indirect %0       ; INDIRECT
    NULL                                ; MEMBERS
    &type_char_indirect %0              ; TYPE
    &type_char_double_indirect_name %0  ; NAME

:type_file
    &type_function %0                   ; NEXT
    %8 %0                               ; SIZE
    NULL                                ; OFFSET
    &type_file %0                       ; INDIRECT
    NULL                                ; MEMBERS
    &type_file %0                       ; TYPE
    &type_file_name %0                  ; NAME

:type_function
    &type_unsigned %0                   ; NEXT
    %8 %0                               ; SIZE
    NULL                                ; OFFSET
    &type_function %0                   ; INDIRECT
    NULL                                ; MEMBERS
    &type_function %0                   ; TYPE
    &type_function_name %0              ; NAME

:type_unsigned
    &type_long %0                       ; NEXT
    %8 %0                               ; SIZE
    NULL                                ; OFFSET
    &type_unsigned %0                   ; INDIRECT
    NULL                                ; MEMBERS
    &type_unsigned %0                   ; TYPE
    &type_unsigned_name %0              ; NAME

:type_long
    NULL                                ; NEXT
    %8 %0                               ; SIZE
    NULL                                ; OFFSET
    &type_long %0                       ; INDIRECT
    NULL                                ; MEMBERS
    &type_long %0                       ; TYPE
    &type_long_name %0                  ; NAME

:type_void_name  "void"
:type_int_name  "int"
:type_char_name  "char"
:type_char_indirect_name  "char*"
:type_char_double_indirect_name  "char**"
:type_file_name  "FILE"
:type_function_name  "FUNCTION"
:type_unsigned_name  "unsigned"
:type_long_name  "long"

:break_frame NULL
:break_target_func NULL
:break_target_head NULL
:break_target_num NULL
:current_target NULL
:global_types &prim_types %0
:strings_list NULL

:alphas
"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"

:symbols
"<=>|&!-"

:strings
'22 27 00'

;; Keywords
:struct  "struct"
:enum "enum"
:main_string  "main"
:argc_string  "argc"
:argv_string  "argv"
:if_string  "if"
:else_string  "else"
:do_string  "do"
:while_string  "while"
:for_string  "for"
:asm_string  "asm"
:goto_string  "goto"
:return_string  "return"
:break_string  "break"
:continue_string  "continue"
:sizeof_string  "sizeof"
:plus_string  "+"
:minus_string  "-"
:multiply_string  "*"
:divide_string  "/"
:modulus_string  "%"
:left_shift_string  "<<"
:right_shift_string  ">>"
:less_than_string  "<"
:less_than_equal_string  "<="
:greater_than_equal_string  ">="
:greater_than_string  ">"
:equal_to_string  "=="
:not_equal_string  "!="
:bitwise_and  "&"
:logical_and  "&&"
:bitwise_or  "|"
:logical_or  "||"
:bitwise_xor  "^"
:arrow_string  "->"

;; Frequently Used strings
;; Generally used by require_match
:open_curly_brace  "{"
:close_curly_brace  "}"
:open_paren  "("
:close_paren  ")"
:open_bracket  "["
:close_bracket  "]"
:comma  ","
:semicolon  ";"
:equal  "="
:percent  "%"
:underline  "_"

;; Strings needed by the program function
:program_string_0  ":GLOBAL_"
:program_string_1
"
NULL
"

:create_struct_string_0
"ERROR in create_struct
 Missing {
"

:create_struct_string_1
"ERROR in create_struct
 Missing ;
"

:header_string1
"
# Core program
"

:header_string2
"
:ELF_data
"

:header_string3
"
# Program global variables
"

:header_string4
"
# Program strings
"

:header_string5
"
:ELF_end
"

:escape_lookup_string_0
"Unknown escape received: "

:escape_lookup_string_1
" Unable to process
"

:type_name_string_0
"Unknown type "

:type_name_string_1
"
"

:lookup_member_string_0
"ERROR in lookup_member "

:lookup_member_string_1
" does not exist
"

:lookup_member_string_2
"
"

:build_member_string_0
"Struct only supports [num] form
"

:declare_function_string_0
"# Defining function "

:declare_function_string_1
"
:FUNCTION_"

:declare_function_string_2
"ret
"

:declare_function_string_3
"
"

:common_recursion_string_0
"rd_sp rs1_sp !-8 addi	# _common_recursion
rs1_sp rs2_a0 sd
"

:common_recursion_string_1
"rd_a1 rs1_sp ld
rd_sp rs1_sp !8 addi	# _common_recursion
"

:recursive_statement_string_0
"ret
"

:recursive_statement_string_1
"rd_a1 rs1_sp ld	# _recursive_statement_locals
rd_sp rs1_sp !8 addi
"

:collect_local_string_0
"# Defining local "

:collect_local_string_1
"
"

:collect_local_string_2
"ERROR in collect_local
Missing ;
"

:collect_local_string_3
"rd_sp rs1_sp !-8 addi
rs1_sp rs2_a0 sd	#"

:return_result_string_0
"ERROR in return_result
MISSING ;
"

:return_result_string_1
"rd_a1 rs1_sp ld	# _return_result_locals
rd_sp rs1_sp !8 addi
"

:return_result_string_2
"ret
"

:statement_string_0
"	#C goto label
"

:statement_string_1
"$"

:statement_string_2
" jal
"

:statement_string_3
"
#continue statement
"

:statement_string_4
"ERROR in statement
Missing ;
"

:process_if_string_0
"# IF_"

:process_if_string_1
"ERROR in process_if
MISSING (
"

:process_if_string_2
"rs1_a0 @8 bnez
$ELSE_"

:process_if_string_2a
"jal
"

:process_if_string_3
"ERROR in process_if
MISSING )
"

:process_if_string_4
"$_END_IF_"

:process_if_string_5
"jal
:ELSE_"

:process_if_string_6
":_END_IF_"

:process_do_string_0
"DO_END_"

:process_do_string_1
":DO_"

:process_do_string_2
"ERROR in process_do
MISSING while
"

:process_do_string_3
"ERROR in process_do
MISSING (
"

:process_do_string_4
"ERROR in process_do
MISSING )
"

:process_do_string_5
"ERROR in process_do
MISSING ;
"

:process_do_string_6
"rs1_a0 @DO_END_"

:process_do_string_6a
"beqz
$DO_"

:process_do_string_7
"jal
:DO_END_"

:process_while_string_0
"END_WHILE_"

:process_while_string_1
":WHILE_"

:process_while_string_2
"ERROR in process_while
MISSING (
"

# Here @8 means jump 8 bytes forward, hence we skip one instruction.
# This slightly abuses M1 encoding since M1 uses @ for S-type instructions
# but we need B-type instruction. Fortunately, B and S encodings are
# identical for values up to 2047.

:process_while_string_3
"rs1_a0 @8 bnez
$END_WHILE_"

:process_while_string_4
"jal
# THEN_while_"

:process_while_string_5
"ERROR in process_while
MISSING )
"

:process_while_string_6
"$WHILE_"

:process_while_string_7
"jal
:END_WHILE_"

:process_for_string_0
"FOR_END_"

:process_for_string_1
"# FOR_initialization_"

:process_for_string_2
"ERROR in process_for
MISSING (
"

:process_for_string_3
":FOR_"

:process_for_string_4
"ERROR in process_for
MISSING ;1
"

:process_for_string_5
"rs1_a0 @8 bnez
$FOR_END_"

:process_for_string_6
"jal
$FOR_THEN_"

:process_for_string_7
"jal
:FOR_ITER_"

:process_for_string_8
"ERROR in process_for
MISSING ;2
"

:process_for_string_9
"$FOR_"

:process_for_string_10
"jal
:FOR_THEN_"

:process_for_string_11
"ERROR in process_for
MISSING )
"

:process_for_string_12
"$FOR_ITER_"

:process_for_string_13
"jal
:FOR_END_"


:process_asm_string_0
"ERROR in process_asm
MISSING (
"

:process_asm_string_1
"
"

:process_asm_string_2
"ERROR in process_asm
MISSING )
"


:process_asm_string_3
"ERROR in process_asm
MISSING ;
"

:process_break_string_0
"Not inside of a loop or case statement"

:process_break_string_1
"rd_a1 rs1_sp ld	# break_cleanup_locals
rd_sp rs1_sp !8 addi
"

:process_break_string_2
"$"

:process_break_string_3
" jal
"

:process_break_string_4
"ERROR in break statement
Missing ;
"

:uniqueID_string_0
"
"

:expression_string_0
"rs1_a1 rs2_a0 sd
"

:expression_string_1
"rs1_a1 rs2_a0 sb
"

:primary_expr_string_0
"rd_a0 mv
"

:primary_expr_string_1
"rd_a0 rs1_a1 rs2_a0 sub
"

:primary_expr_string_2
"rd_a0 !1 addi
"

:primary_expr_string_3
"rd_a0 rs1_a1 rs2_a0 xor
"

:primary_expr_string_4
"rd_a0 rs1_a0 not
"

:primary_expr_string_5
"Error in Primary expression
Didn't get )
"

:primary_expr_string_6
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"

:primary_expr_string_7
"0123456789"

:primary_expr_variable_string_0
" is not a defined symbol
"

:primary_expr_variable_string_1
"rd_a0 ~"

:primary_expr_variable_string_2
" lui
rd_a0 rs1_a0 !"

:primary_expr_variable_string_3
" addiw
"

:primary_expr_number_string_0
"rd_a0 ~"

:primary_expr_number_string_1
" lui
rd_a0 rs1_a0 !"
:primary_expr_number_string_2
" addiw
"

:unary_expr_sizeof_string_0
"ERROR in unary_expr
Missing (
"

:unary_expr_sizeof_string_1
"ERROR in unary_expr
Missing )
"

:unary_expr_sizeof_string_2
"rd_a0 !"

:unary_expr_sizeof_string_3
" addi
"

:primary_expr_char_string_0
"rd_a0 !"

:primary_expr_char_string_1
" addi
"

:primary_expr_string_string_0
"rd_a0 ~STRING_"

:primary_expr_string_string_1
"auipc
rd_a0 rs1_a0 !STRING_"

:primary_expr_string_string_2
"addi
"

:primary_expr_string_string_3
":STRING_"

:primary_expr_failure_string_0
"Received "

:primary_expr_failure_string_1
" in primary_expr
"

:weird_string_0
"	
 !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"

:weird_string_1
'09 0a 0d 20 00'

:bitwise_expr_stub_string_0  "rd_a0 rs1_a1 rs2_a0 and
"
:bitwise_expr_stub_string_1  "rd_a0 rs1_a1 rs2_a0 or
"
:bitwise_expr_stub_string_2  "rd_a0 rs1_a1 rs2_a0 xor
"

:relational_expr_stub_string_0  "rd_a0 rs1_a1 rs2_a0 slt
"

:relational_expr_stub_string_1  "rd_a0 rs1_a0 rs2_a1 slt
rd_a0 rs1_a0 !1 xori
"

:relational_expr_stub_string_2  "rd_a0 rs1_a1 rs2_a0 slt
rd_a0 rs1_a0 !1 xori
"

:relational_expr_stub_string_3  "rd_a0 rs1_a0 rs2_a1 slt
"

:relational_expr_stub_string_4  "rd_a0 rs1_a0 rs2_a1 sub
rd_a0 rs1_a0 !1 sltiu
"
:relational_expr_stub_string_5  "rd_a0 rs1_a0 rs2_a1 sub
rd_a0 rs2_a0 sltu
"

:additive_expr_stub_string_0  "rd_a0 rs1_a1 rs2_a0 add
"
:additive_expr_stub_string_1  "rd_a0 rs1_a1 rs2_a0 sub
"
:additive_expr_stub_string_2  "rd_a0 rs1_a1 rs2_a0 mul
"
:additive_expr_stub_string_3  "rd_a0 rs1_a1 rs2_a0 div
"
:additive_expr_stub_string_4  "rd_a0 rs1_a1 rs2_a0 rem
"
:additive_expr_stub_string_5  "rd_a0 rs1_a1 rs2_a0 sll
"
:additive_expr_stub_string_6  "rd_a0 rs1_a1 rs2_a0 srl
"

:postfix_expr_array_string_0
"rd_a0 rs1_a0 ld
"

:postfix_expr_array_string_1
"rd_a0 rs1_a0 lbu
"

:postfix_expr_array_string_2
"rd_a0 rs1_a0 rs2_x"

:postfix_expr_array_string_3
" slli
"

:postfix_expr_array_string_4
"rd_a0 rs1_a1 rs2_a0 add
"

:postfix_expr_array_string_5
"ERROR in postfix_expr
Missing ]
"

:postfix_expr_array_string_6
'00'

:postfix_expr_arrow_string_0
"# looking up offset
"

:postfix_expr_arrow_string_1
"# -> offset calculation
rd_a1 !"

:postfix_expr_arrow_string_2
" addi
rd_a0 rs1_a1 rs2_a0 add
"

:postfix_expr_arrow_string_3
"rd_a0 rs1_a0 ld
"

:variable_load_string_0
"rd_a0 rs1_fp !-"

:variable_load_string_1
" addi
"

:variable_load_string_2
"rd_a0 rs1_a0 ld
"

:global_load_string_0
"rd_a0 ~GLOBAL_"

:global_load_string_1
" auipc
rd_a0 rs1_a0 !GLOBAL_"

:global_load_string_2
" addi
"

:global_load_string_3
"rd_a0 rs1_a0 ld
"

:function_load_string_0
"rd_a0 ~FUNCTION_"

:function_load_string_1
" auipc
rd_a0 rs1_a0 !FUNCTION_"

:function_load_string_2
" addiw
"

:function_call_string_0
"ERROR in process_expression_list
No ( was found
"

:function_call_string_1
"rd_sp rs1_sp !-24 addi
rs1_sp rs2_ra @8 sd	# Protect the old return pointer
"

:function_call_string_2
"rs1_sp rs2_fp sd	# Protect the old frame pointer
"

:function_call_string_2a
"rs1_sp rs2_tp @16 sd	# Protect temp register we are going to use
"

:function_call_string_2b
"rd_tp rs1_sp mv	# The base pointer to-be
"

:function_call_string_3
"rd_fp rs1_sp mv	# Copy new base pointer
"

:function_call_string_4
"rd_sp rs1_sp !-8 addi
rs1_sp rs2_a0 sd	#_process_expression1
"

:function_call_string_5
"rd_sp rs1_sp !-8 addi
rs1_sp rs2_a0 sd	#_process_expression2
"

:function_call_string_6
"ERROR in process_expression_list
No ) was found
"

:function_call_string_7
"rd_a0 rs1_fp !-"

:function_call_string_8
" addi
rd_a0 rs1_a0 ld
"

:function_call_string_9
"rd_fp rs1_tp mv
"

:function_call_string_10
"rd_ra rs1_a0 jalr
"

:function_call_string_10a
"rd_fp rs1_tp mv
"

:function_call_string_11
"rd_ra $FUNCTION_"

:function_call_string_12
" jal
"

:function_call_string_13
"rd_a1 rs1_sp ld	# _process_expression_locals
rd_sp rs1_sp !8 addi
"

:function_call_string_14
"rd_fp rs1_sp ld	# Restore old frame pointer
"

:function_call_string_14a
"rd_tp rs1_sp !16 ld	# Restore temp register
"

:function_call_string_15
"rd_ra rs1_sp !8 ld	# Restore return address
rd_sp rs1_sp !24 addi
"

:char2hex_string_0
"Tried to print non-hex number
"

:debug_list_string0  "Token_list node at address: "
:debug_list_string1  "
NEXT address: "
:debug_list_string2  "
PREV address: "
:debug_list_string3  "
S address: "
:debug_list_string4  "
The contents of S are: "
:debug_list_string5  "
TYPE address: "
:debug_list_string6  "
ARGUMENTS address: "
:debug_list_string_null  ">::<NULL>::<"

:ELF_end
